<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" manifest="passlok.appcache">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>PassLok privacy</title>
    <style type="text/css">
		html {
	    -webkit-text-size-adjust: 100%;
		}
	    body {
		font-family: Sans-Serif;
		margin-left: 1%;
		margin-right: 1%;
		background-color: #FFFFFF;
		color: #000000;
		overflow: auto;
	    }
		.black_overlay{
			display: none;
			position: absolute;
			top: 0%;
			left: 0%;
			width: 100%;
			height: 100%;
			background-color: black;
			z-index:1001;
			-moz-opacity: 0.5;
			opacity:.50;
			filter: alpha(opacity=50);
		}
		.white_content {
			display: none;
			position: absolute;
			top: 15%;
			left: 15%;
			width: 70%;
			height: 70%;
			padding: 0px;
			border: 0px solid gray;
			background-color: white;
			z-index:1002;
			overflow: auto;       
		}
		input[type=checkbox]{
  		/* Larger checkboxes */
  			-ms-transform: scale(1.7); /* IE */
 			-moz-transform: scale(1.7); /* FF */
  			-webkit-transform: scale(1.7); /* Safari and Chrome */
  			-o-transform: scale(1.7); /* Opera */
  			padding: 0px;
			border:1px solid #dcdcdc;
		}
		input[type=radio]{
  		/* Larger radio buttons */
  			-ms-transform: scale(1.7); /* IE */
 			-moz-transform: scale(1.7); /* FF */
  			-webkit-transform: scale(1.7); /* Safari and Chrome */
  			-o-transform: scale(1.7); /* Opera */
  			padding: 0px;
			border:1px solid #dcdcdc;
		}
.cssbutton {
	-moz-box-shadow:inset 0px 1px 0px 0px #ffffff;
	-webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;
	box-shadow:inset 0px 1px 0px 0px #ffffff;
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ededed), color-stop(1, #dfdfdf) );
	background:-moz-linear-gradient( center top, #ededed 5%, #dfdfdf 100% );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ededed', endColorstr='#dfdfdf');
	background-color:#ededed;
	-webkit-border-top-left-radius:6px;
	-moz-border-radius-topleft:6px;
	border-top-left-radius:6px;
	-webkit-border-top-right-radius:6px;
	-moz-border-radius-topright:6px;
	border-top-right-radius:6px;
	-webkit-border-bottom-right-radius:6px;
	-moz-border-radius-bottomright:6px;
	border-bottom-right-radius:6px;
	-webkit-border-bottom-left-radius:6px;
	-moz-border-radius-bottomleft:6px;
	border-bottom-left-radius:6px;
	text-indent:0;
	border:1px solid #dcdcdc;
	display:inline-block;
	color:#666666;
	font-size:15px;
	font-weight:bold;
	font-style:normal;
	height:35px;
	line-height:35px;
	width:75px;
	text-decoration:none;
	text-align:center;
	text-shadow:1px 1px 0px #ffffff;
}
.cssbutton:hover {
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #dfdfdf), color-stop(1, #ededed) );
	background:-moz-linear-gradient( center top, #dfdfdf 5%, #ededed 100% );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#dfdfdf', endColorstr='#ededed');
	background-color:#dfdfdf;
}
.cssbutton:active {
	position:relative;
	top:1px;
}
.cssbox {
	-webkit-border-top-left-radius:6px;
	-moz-border-radius-topleft:6px;
	border-top-left-radius:6px;
	-webkit-border-top-right-radius:6px;
	-moz-border-radius-topright:6px;
	border-top-right-radius:6px;
	-webkit-border-bottom-right-radius:6px;
	-moz-border-radius-bottomright:6px;
	border-bottom-right-radius:6px;
	-webkit-border-bottom-left-radius:6px;
	-moz-border-radius-bottomleft:6px;
	border-bottom-left-radius:6px;
	text-indent:0;
	border:4px solid #dfdfdf;
	background-color: #ffffee;
	color:#000000;
	font-size:15px;
	font-style:normal;
	text-align:left;
	text-decoration:none;	
}
	</style>
      
    <meta name="Keywords" content="passlok, URSA, browser, encryption, decryption, symmetric, public key, signature, AES, ECDH, Diffie, Hellman, elliptic curve, advanced, javascript, PGP, PRISM">
    <meta name="Description" content="PassLok privacy">
    <meta name="author" content="F. Ruiz">
    <meta name="robots" content="index">
    <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no">
	
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<link rel="apple-touch-icon" href="passlok-touch-icon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

<script>
        /* 
		@source: https://passlok.com/index.html
		   
        @licstart  The following is the entire license notice for the 
        JavaScript code in this page.

        Copyright (C) 2014  Francisco Ruiz

        The JavaScript code in this page is free software: you can
        redistribute it and/or modify it under the terms of the GNU
        General Public License (GNU GPL) as published by the Free Software
        Foundation, either version 3 of the License, or (at your option)
        any later version.  The code is distributed WITHOUT ANY WARRANTY;
        without even the implied warranty of MERCHANTABILITY or FITNESS
        FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

        As additional permission under GNU GPL version 3 section 7, you
        may distribute non-source (e.g., minimized or compacted) forms of
        that code without the copy of the GNU GPL normally required by
        section 4, provided you include this license notice and a URL
        through which recipients can access the Corresponding Source.   


        @licend  The above is the entire license notice
        for the JavaScript code in this page.
        */

    if (window.location.protocol == "http:") {				//force SSL/TLS

        var restOfUrl = window.location.href.substr(5);
        window.location = "https:" + restOfUrl;
    }

// secrets.js - by Alexander Stetsyuk - released under MIT License
//substantial edits by F. Ruiz: since RNG used is from SJCL, RNG check is left to SJCL: RNG checking code removed from here.

(function(exports, global){
var defaults = {
	bits: 8, // default number of bits
	radix: 16, // work with HEX by default
	minBits: 3,
	maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!
	
	bytesPerChar: 2,
	maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)
		
	// Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30
	// The index of each term in the array corresponds to the n for that polynomial
	// i.e. to get the polynomial for n=16, use primitivePolynomials[16]
	primitivePolynomials: [null,null,1,3,3,5,3,3,29,17,9,5,83,27,43,3,45,9,39,39,9,5,3,33,27,9,71,39,9,5,83],
	
	// warning for insecure PRNG
	warning: 'WARNING:\nA secure random number generator was not found.\nUsing Math.random(), which is NOT cryptographically strong!'
};

// Protected settings object
var config = {};

function init(bits){
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	config.radix = defaults.radix;
	config.bits = bits || defaults.bits;
	config.size = Math.pow(2, config.bits);
	config.max = config.size - 1;
	
	// Construct the exp and log tables for multiplication.	
	var logs = [], exps = [], x = 1, primitive = defaults.primitivePolynomials[config.bits];
	for(var i=0; i<config.size; i++){
		exps[i] = x;
		logs[x] = i;
		x <<= 1;
		if(x >= config.size){
			x ^= primitive;
			x &= config.max;
		}
	}		
	config.logs = logs;
	config.exps = exps;
};

/** @expose **/
exports.init = init;

// Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16) 
// into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`), 
// requiring `threshold` number of shares to reconstruct the secret. 
// Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.
/** @expose **/
exports.share = function(secret, numShares, threshold, padLength){
	padLength =  padLength || 0;
		
	if(typeof secret !== 'string'){
		throw new Error('Secret must be a string.');
	}
	if(typeof numShares !== 'number' || numShares%1 !== 0 || numShares < 2){
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.')
	}
	if(numShares > config.max){
		var neededBits = Math.ceil(Math.log(numShares +1)/Math.LN2);
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive. To create ' + numShares + ' shares, use at least ' + neededBits + ' bits.')	
	}
	if(typeof threshold !== 'number' || threshold%1 !== 0 || threshold < 2){
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.');
	}
	if(threshold > config.max){
		var neededBits = Math.ceil(Math.log(threshold +1)/Math.LN2);
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.  To use a threshold of ' + threshold + ', use at least ' + neededBits + ' bits.');
	}
	if(typeof padLength !== 'number' || padLength%1 !== 0 ){
		throw new Error('Zero-pad length must be an integer greater than 1.');
	}	
	secret = '1' + hex2bin(secret); // append a 1 so that we can preserve the correct number of leading zeros in our secret
	secret = split(secret, padLength);	
	var x = new Array(numShares), y = new Array(numShares);
	for(var i=0, len = secret.length; i<len; i++){
		var subShares = this._getShares(secret[i], numShares, threshold);
		for(var j=0; j<numShares; j++){
			x[j] = x[j] || subShares[j].x.toString(config.radix);
			y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] ? y[j] : '');
		}
	}
	var padding = config.max.toString(config.radix).length;
	for(var i=0; i<numShares; i++){
		x[i] = config.bits.toString(36) + padLeft(x[i],padding) + bin2hex(y[i]);
	}		
	return x;
};

// This is the basic polynomial generation and evaluation function 
// for a `config.bits`-length secret (NOT an arbitrary length)
// Note: no error-checking at this stage! If `secrets` is NOT 
// a NUMBER less than 2^bits-1, the output will be incorrect!
/** @expose **/
exports._getShares = function(secret, numShares, threshold){	
	var shares = [];
	var coeffs = [secret];
	var limit = Math.pow(2,config.bits); 		
	for(var i=1; i<threshold; i++){
//		coeffs[i] = parseInt(config.rng(config.bits),2);		//original random decimal number of maximum size 2^config.bits
		coeffs[i]=sjcl.bn.random(limit).limbs[0];				//using SJCL RNG
	}
	for(var i=1, len = numShares+1; i<len; i++){
		shares[i-1] = {
			x: i,
			y: horner(i, coeffs)
		}
	}
	return shares;
};
	
// Polynomial evaluation at `x` using Horner's Method
// TODO: this can possibly be sped up using other methods
// NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i], 
//       so if fx===0, just set fx to coeff[i] because
//       using the exp/log form will result in incorrect value
function horner(x, coeffs){
	var logx = config.logs[x];
	var fx = 0;
	for(var i=coeffs.length-1; i>=0; i--){	
		if(fx === 0){
			fx = coeffs[i];
			continue;
		}
		fx = config.exps[ (logx + config.logs[fx]) % config.max ] ^ coeffs[i];
	}
	return fx;
};

function inArray(arr,val){
	for(var i = 0,len=arr.length; i < len; i++) {
		if(arr[i] === val){
   		 return true;
	 	}
 	}
	return false;
};

function processShare(share){
	
	var bits = parseInt(share[0], 36);
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	var max = Math.pow(2, bits) - 1;
	var idLength = max.toString(config.radix).length;
	
	var id = parseInt(share.substr(1, idLength), config.radix);
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}
	share = share.substr(idLength + 1);
	if(!share.length){
		throw new Error('Invalid share: zero-length share.')
	}
	return {
		'bits': bits,
		'id': id,
		'value': share
	};
};

/** @expose **/
secrets._processShare = processShare;

// Protected method that evaluates the Lagrange interpolation
// polynomial at x=`at` for individual config.bits-length
// segments of each share in the `shares` Array.
// Each share is expressed in base `inputRadix`. The output 
// is expressed in base `outputRadix'
function combine(at, shares){
	var setBits, share, x = [], y = [], result = '', idx;	
	
	for(var i=0, len = shares.length; i<len; i++){
		share = processShare(shares[i]);
		if(typeof setBits === 'undefined'){
			setBits = share['bits'];
		}else if(share['bits'] !== setBits){
			throw new Error('Mismatched shares: Different bit settings.')
		}		
		if(config.bits !== setBits){
			init(setBits);
		}		
		if(inArray(x, share['id'])){ // repeated x value?
			continue;
		}	
		idx = x.push(share['id']) - 1;
		share = split(hex2bin(share['value']));
		for(var j=0, len2 = share.length; j<len2; j++){
			y[j] = y[j] || [];
			y[j][idx] = share[j];
		}
	}	
	for(var i=0, len=y.length; i<len; i++){
		result = padLeft(lagrange(at, x, y[i]).toString(2)) + result;
	}
	if(at===0){// reconstructing the secret
		var idx = result.indexOf('1'); //find the first 1
		return bin2hex(result.slice(idx+1));
	}else{// generating a new share
		return bin2hex(result);
	}
};

// Combine `shares` Array into the original secret
/** @expose **/
exports.combine = function(shares){
	return combine(0, shares);
};

// Generate a new share with id `id` (a number between 1 and 2^bits-1)
// `id` can be a Number or a String in the default radix (16)
/** @expose **/
exports.newShare = function(id, shares){
	if(typeof id === 'string'){
		id = parseInt(id, config.radix);	
	}
	
	var share = processShare(shares[0]);
	var max = Math.pow(2, share['bits']) - 1;
	
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}

	var padding = max.toString(config.radix).length;
	return config.bits.toString(36) + padLeft(id.toString(config.radix), padding) + combine(id, shares);
};

// Evaluate the Lagrange interpolation polynomial at x = `at`
// using x and y Arrays that are of the same length, with
// corresponding elements constituting points on the polynomial.
function lagrange(at, x, y){
	var sum = 0,
		product, 
		i, j;
		
	for(var i=0, len = x.length; i<len; i++){
		if(!y[i]){
			continue; 
		}			
		product = config.logs[y[i]];
		for(var j=0; j<len; j++){
			if(i === j){ continue; }
			if(at === x[j]){ // happens when computing a share that is in the list of shares used to compute it
				product = -1; // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1
				break; 
			}
			product = ( product + config.logs[at ^ x[j]] - config.logs[x[i] ^ x[j]] + config.max/* to make sure it's not negative */ ) % config.max;
		}			
		sum = product === -1 ? sum : sum ^ config.exps[product]; // though exps[-1]= undefined and undefined ^ anything = anything in chrome, this behavior may not hold everywhere, so do the check
	}
	return sum;
};

/** @expose **/
exports._lagrange = lagrange;

// Splits a number string `bits`-length segments, after first 
// optionally zero-padding it to a length that is a multiple of `padLength.
// Returns array of integers (each less than 2^bits-1), with each element
// representing a `bits`-length segment of the input string from right to left, 
// i.e. parts[0] represents the right-most `bits`-length segment of the input string.
function split(str, padLength){
	if(padLength){
		str = padLeft(str, padLength)
	}
	var parts = [];
	for(var i=str.length; i>config.bits; i-=config.bits){
		parts.push(parseInt(str.slice(i-config.bits, i), 2));
	}	
	parts.push(parseInt(str.slice(0, i), 2));	
	return parts;
};
	
// Pads a string `str` with zeros on the left so that its length is a multiple of `bits`
function padLeft(str, bits){
	bits = bits || config.bits
	var missing = str.length % bits;
	return (missing ? new Array(bits - missing + 1).join('0') : '') + str;
};

function hex2bin(str){
	var bin = '', num;
	for(var i=str.length - 1; i>=0; i--){
		num = parseInt(str[i], 16)
		if(isNaN(num)){
			throw new Error('Invalid hex character.')
		}
		bin = padLeft(num.toString(2), 4) + bin;
	}
	return bin;
}

function bin2hex(str){
	var hex = '', num;
	str = padLeft(str, 4);
	for(var i=str.length; i>=4; i-=4){
		num = parseInt(str.slice(i-4, i), 2);
		if(isNaN(num)){
			throw new Error('Invalid binary character.')
		}
		hex = num.toString(16) + hex;
	}
	return hex;
}
	
// by default, initialize without an RNG
exports.init();
})(typeof module !== 'undefined' && module['exports'] ? module['exports'] : (window['secrets'] = {}), typeof GLOBAL !== 'undefined' ? GLOBAL : window );


//PixelJihad method for hiding text in images, by Zach Oakes

// put image in the canvas and display it
var importImage = function(e) {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("An image stored in this device will replace the current image. Cancel if this is not what you want.");
		if(reply==false) throw("image import canceled");
	}
//end of learn mode dialog
	
    var reader = new FileReader();

    reader.onload = function(event) {
        // set the preview
        document.getElementById('preview').style.display = 'block';
        document.getElementById('preview').src = event.target.result;

        // read the data into the canvas element
        var img = new Image();
        img.onload = function() {
            var ctx = document.getElementById('canvas').getContext('2d');
            ctx.canvas.width = img.width;
            ctx.canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
        };
        img.src = event.target.result;
    };

    reader.readAsDataURL(e.target.files[0]);
	document.getElementById('imagemsg').innerHTML=''
};

// encode the image and save it
var encodeImage = function() {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in the previous box will be encoded into this image, which can then be copied and sent to others. Cancel if this is not what you want.");
		if(reply==false) throw("encode image canceled");
	}
//end of learn mode dialog
	
	var imagemsg = document.getElementById('imagemsg');
    var message = document.getElementById('mainBox').value;
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

//bail out if this is not a PassLok string. This part inserted by F. Ruiz
	for (var i = 0; i < message.length; i++){
		var index = keystr.indexOf(message[i]);			//keystr is a global variable defined in the text steganography section
		if(index == -1){
			imagemsg.innerHTML = '<span style="color:red">The text contains illegal characters for a PassLok string</span>';
			throw("illegal characters in box")
		}
	}
//continue Oakes code
	
        message = JSON.stringify({'text': message});

    // exit early if the message is too big for the image
    var pixelCount = ctx.canvas.width * ctx.canvas.height;
    if ((message.length + 1) * 16 > pixelCount * 4 * 0.75) {
		imagemsg.innerHTML = 'The text is too large for the image';
        return;
    }

    // encode the encrypted message with the supplied password
    var imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    encodeMessage(imgData.data, sjcl.hash.sha256.hash(""), message);
    ctx.putImageData(imgData, 0, 0);

    // view the new image
	imagemsg.innerHTML = 'Text hidden in the image. Save it now.'
    preview.src = canvas.toDataURL();
};

// decode the image and display the contents if there is anything
var decodeImage = function() {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text hidden in this image, if any, will be extracted and placed in the previous box, replacing its contents. This does not yet work on mobile devices. Cancel if this is not what you want.");
		if(reply==false) throw("decode image canceled");
	}
//end of learn mode dialog
	
	var imagemsg = document.getElementById('imagemsg');	
    var ctx = document.getElementById('canvas').getContext('2d');
    var imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    var message = decodeMessage(imgData.data, sjcl.hash.sha256.hash(""));

    // try to parse the JSON
    var obj = null;
    try {
        obj = JSON.parse(message);
		imagemsg.innerHTML = 'This image contains a message. Go back to see it.'
    } catch (e) {
		imagemsg.innerHTML = 'This image does not contain a message.'
    }
	document.getElementById('mainBox').value = obj.text
};

// returns a 1 or 0 for the bit in 'location'
var getBit = function(number, location) {
   return ((number >> location) & 1);
};

// sets the bit in 'location' to 'bit' (either a 1 or 0)
var setBit = function(number, location, bit) {
   return (number & ~(1 << location)) | (bit << location);
};

// returns an array of 1s and 0s for a 2-byte number
var getBitsFromNumber = function(number) {
   var bits = [];
   for (var i = 0; i < 16; i++) {
       bits.push(getBit(number, i));
   }
   return bits;
};

// returns the next 2-byte number
var getNumberFromBits = function(bytes, history, hash) {
    var number = 0, pos = 0;
    while (pos < 16) {
        var loc = getNextLocation(history, hash, bytes.length);
        var bit = getBit(bytes[loc], 0);
        number = setBit(number, pos, bit);
        pos++;
    }
    return number;
};

// returns an array of 1s and 0s for the string 'message'
var getMessageBits = function(message) {
    var messageBits = [];
    for (var i = 0; i < message.length; i++) {
        var code = message.charCodeAt(i);
        messageBits = messageBits.concat(getBitsFromNumber(code));
    }
    return messageBits;
};

// gets the next location to store a bit
var getNextLocation = function(history, hash, total) {
    var pos = history.length;
    var loc = Math.abs(hash[pos % hash.length] * (pos + 1)) % total;
    while (true) {
        if (loc >= total) {
            loc = 0;
        } else if (history.indexOf(loc) >= 0) {
            loc++;
        } else if ((loc + 1) % 4 === 0) {
            loc++;
        } else {
            history.push(loc);
            return loc;
        }
    }
};

// encodes the supplied 'message' into the CanvasPixelArray 'colors'
var encodeMessage = function(colors, hash, message) {
    // make an array of bits from the message
    var messageBits = getBitsFromNumber(message.length);
    messageBits = messageBits.concat(getMessageBits(message));

    // this will store the color values we've already modified
    var history = [];

    // encode the bits into the pixels
    var pos = 0;
    while (pos < messageBits.length) {
        // set the next color value to the next bit
        var loc = getNextLocation(history, hash, colors.length);
        colors[loc] = setBit(colors[loc], 0, messageBits[pos]);

        // set the alpha value in this pixel to 255
        // we have to do this because browsers do premultiplied alpha
        // see for example: http://stackoverflow.com/q/4309364
        while ((loc + 1) % 4 !== 0) {
            loc++;
        }
        colors[loc] = 255;

        pos++;
    }
};

// returns the message encoded in the CanvasPixelArray 'colors'
var decodeMessage = function(colors, hash) {
    // this will store the color values we've already read from
    var history = [];

    // get the message size
    var messageSize = getNumberFromBits(colors, history, hash);

    // exit early if the message is too big for the image
    if ((messageSize + 1) * 16 > colors.length * 0.75) {
        return '';
    }

    // put each character into an array
    var message = [];
    for (var i = 0; i < messageSize; i++) {
        var code = getNumberFromBits(colors, history, hash);
        message.push(String.fromCharCode(code));
    }

    // the characters should parse into valid JSON
    return message.join('');
};


/*SJCL.js begins
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Jeff Mott
 * @author Stefan Thomas
 */

"use strict";
var sjcl = {
    cipher: {},
    hash: {},
    keyexchange: {},
    mode: {},
    misc: {},
    codec: {},
    exception: {
	corrupt: function (a) {
	    this.toString = function () {
		return "CORRUPT: " + this.message
	    };
	    this.message = a
	},
	invalid: function (a) {
	    this.toString = function () {
		return "INVALID: " + this.message
	    };
	    this.message = a
	},
	bug: function (a) {
	    this.toString = function () {
		return "BUG: " + this.message
	    };
	    this.message = a
	},
	notReady: function (a) {
	    this.toString = function () {
		return "NOT READY: " + this.message
	    };
	    this.message = a
	}
    }
};
if (typeof module != "undefined" && module.exports) module.exports = sjcl;
sjcl.cipher.aes = function (a) {
    this.h[0][0][0] || this.z();
    var b, c, d, e, f = this.h[0][4],
	g = this.h[1];
    b = a.length;
    var h = 1;
    if (b !== 4 && b !== 6 && b !== 8) throw new sjcl.exception.invalid("invalid aes key size");
    this.a = [d = a.slice(0), e = []];
    for (a = b; a < 4 * b + 28; a++) {
	c = d[a - 1];
	if (a % b === 0 || b === 8 && a % b === 4) {
	    c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255];
	    if (a % b === 0) {
		c = c << 8 ^ c >>> 24 ^ h << 24;
		h = h << 1 ^ (h >> 7) * 283
	    }
	}
	d[a] = d[a - b] ^ c
    }
    for (b = 0; a; b++, a--) {
	c = d[b & 3 ? a : a - 4];
	e[b] = a <= 4 || b < 4 ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]]
    }
};
sjcl.cipher.aes.prototype = {
    encrypt: function (a) {
	return this.I(a, 0)
    },
    decrypt: function (a) {
	return this.I(a, 1)
    },
    h: [
	[
	    [],
	    [],
	    [],
	    [],
	    []
	],
	[
	    [],
	    [],
	    [],
	    [],
	    []
	]
    ],
    z: function () {
	var a = this.h[0],
	    b = this.h[1],
	    c = a[4],
	    d = b[4],
	    e, f, g, h = [],
	    i = [],
	    k, j, l, m;
	for (e = 0; e < 0x100; e++) i[(h[e] = e << 1 ^ (e >> 7) * 283) ^ e] = e;
	for (f = g = 0; !c[f]; f ^= k || 1, g = i[g] || 1) {
	    l = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
	    l = l >> 8 ^ l & 255 ^ 99;
	    c[f] = l;
	    d[l] = f;
	    j = h[e = h[k = h[f]]];
	    m = j * 0x1010101 ^ e * 0x10001 ^ k * 0x101 ^ f * 0x1010100;
	    j = h[l] * 0x101 ^ l * 0x1010100;
	    for (e = 0; e < 4; e++) {
		a[e][f] = j = j << 24 ^ j >>> 8;
		b[e][l] = m = m << 24 ^ m >>> 8
	    }
	}
	for (e = 0; e < 5; e++) {
	    a[e] = a[e].slice(0);
	    b[e] = b[e].slice(0)
	}
    },
    I: function (a, b) {
	if (a.length !== 4) throw new sjcl.exception.invalid("invalid aes block size");
	var c = this.a[b],
	    d = a[0] ^ c[0],
	    e = a[b ? 3 : 1] ^ c[1],
	    f = a[2] ^ c[2];
	a = a[b ? 1 : 3] ^ c[3];
	var g, h, i, k = c.length / 4 - 2,
	    j, l = 4,
	    m = [0, 0, 0, 0];
	g = this.h[b];
	var n = g[0],
	    o = g[1],
	    p = g[2],
	    q = g[3],
	    r = g[4];
	for (j = 0; j < k; j++) {
	    g = n[d >>> 24] ^ o[e >> 16 & 255] ^ p[f >> 8 & 255] ^ q[a & 255] ^ c[l];
	    h = n[e >>> 24] ^ o[f >> 16 & 255] ^ p[a >> 8 & 255] ^ q[d & 255] ^ c[l + 1];
	    i = n[f >>> 24] ^ o[a >> 16 & 255] ^ p[d >> 8 & 255] ^ q[e & 255] ^ c[l + 2];
	    a = n[a >>> 24] ^ o[d >> 16 & 255] ^ p[e >> 8 & 255] ^ q[f & 255] ^ c[l + 3];
	    l += 4;
	    d = g;
	    e = h;
	    f = i
	}
	for (j = 0; j < 4; j++) {
	    m[b ? 3 & -j : j] = r[d >>> 24] << 24 ^ r[e >> 16 & 255] << 16 ^ r[f >> 8 & 255] << 8 ^ r[a & 255] ^ c[l++];
	    g = d;
	    d = e;
	    e = f;
	    f = a;
	    a = g
	}
	return m
    }
};
sjcl.bitArray = {
    bitSlice: function (a, b, c) {
	a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
	return c === undefined ? a : sjcl.bitArray.clamp(a, c - b)
    },
    extract: function (a, b, c) {
	var d = Math.floor(-b - c & 31);
	return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1
    },
    concat: function (a, b) {
	if (a.length === 0 || b.length === 0) return a.concat(b);
	var c = a[a.length - 1],
	    d = sjcl.bitArray.getPartial(c);
	return d === 32 ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1))
    },
    bitLength: function (a) {
	var b = a.length;
	if (b === 0) return 0;
	return (b - 1) * 32 + sjcl.bitArray.getPartial(a[b - 1])
    },
    clamp: function (a, b) {
	if (a.length * 32 < b) return a;
	a = a.slice(0, Math.ceil(b / 32));
	var c = a.length;
	b &= 31;
	if (c > 0 && b) a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1);
	return a
    },
    partial: function (a, b, c) {
	if (a === 32) return b;
	return (c ? b | 0 : b << 32 - a) + a * 0x10000000000
    },
    getPartial: function (a) {
	return Math.round(a / 0x10000000000) || 32
    },
    equal: function (a, b) {
	if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return false;
	var c = 0,
	    d;
	for (d = 0; d < a.length; d++) c |= a[d] ^ b[d];
	return c === 0
    },
    P: function (a, b, c, d) {
	var e;
	e = 0;
	if (d === undefined) d = [];
	for (; b >= 32; b -= 32) {
	    d.push(c);
	    c = 0
	}
	if (b === 0) return d.concat(a);
	for (e = 0; e < a.length; e++) {
	    d.push(c | a[e] >>> b);
	    c = a[e] << 32 - b
	}
	e = a.length ? a[a.length - 1] : 0;
	a = sjcl.bitArray.getPartial(e);
	d.push(sjcl.bitArray.partial(b + a & 31, b + a > 32 ? c : d.pop(), 1));
	return d
    },
    k: function (a, b) {
	return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
    }
};
sjcl.codec.utf8String = {
    fromBits: function (a) {
	var b = "",
	    c = sjcl.bitArray.bitLength(a),
	    d, e;
	for (d = 0; d < c / 8; d++) {
	    if ((d & 3) === 0) e = a[d / 4];
	    b += String.fromCharCode(e >>> 24);
	    e <<= 8
	}
	return decodeURIComponent(escape(b))
    },
    toBits: function (a) {
	a = unescape(encodeURIComponent(a));
	var b = [],
	    c, d = 0;
	for (c = 0; c < a.length; c++) {
	    d = d << 8 | a.charCodeAt(c);
	    if ((c & 3) === 3) {
		b.push(d);
		d = 0
	    }
	}
	c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
	return b
    }
};
sjcl.codec.hex = {
    fromBits: function (a) {
	var b = "",
	    c;
	for (c = 0; c < a.length; c++) b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
	return b.substr(0, sjcl.bitArray.bitLength(a) / 4)
    },
    toBits: function (a) {
	var b, c = [],
	    d;
	a = a.replace(/\s|0x/g, "");
	d = a.length;
	a += "00000000";
	for (b = 0; b < a.length; b += 8) c.push(parseInt(a.substr(b, 8), 16) ^ 0);
	return sjcl.bitArray.clamp(c, d * 4)
    }
};
sjcl.codec.base64 = {
    F: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    fromBits: function (a, b, c) {
	var d = "",
	    e = 0,
	    f = sjcl.codec.base64.F,
	    g = 0,
	    h = sjcl.bitArray.bitLength(a);
	if (c) f = f.substr(0, 62) + "-_";
	for (c = 0; d.length * 6 < h;) {
	    d += f.charAt((g ^ a[c] >>> e) >>> 26);
	    if (e < 6) {
		g = a[c] << 6 - e;
		e += 26;
		c++
	    } else {
		g <<= 6;
		e -= 6
	    }
	}
	for (; d.length & 3 && !b;) d += "=";
	return d
    },
    toBits: function (a, b) {
	a = a.replace(/\s|=/g, "");
	var c = [],
	    d = 0,
	    e = sjcl.codec.base64.F,
	    f = 0,
	    g;
	if (b) e = e.substr(0, 62) + "-_";
	for (b = 0; b < a.length; b++) {
	    g = e.indexOf(a.charAt(b));
	    if (g < 0) throw new sjcl.exception.invalid("this isn't base64!");
	    if (d > 26) {
		d -= 26;
		c.push(f ^ g >>> d);
		f = g << 32 - d
	    } else {
		d += 6;
		f ^= g << 32 - d
	    }
	}
	d & 56 && c.push(sjcl.bitArray.partial(d & 56, f, 1));
	return c
    }
};
sjcl.codec.base64url = {
    fromBits: function (a) {
	return sjcl.codec.base64.fromBits(a, 1, 1)
    },
    toBits: function (a) {
	return sjcl.codec.base64.toBits(a, 1)
    }
};
sjcl.hash.sha256 = function (a) {
    this.a[0] || this.z();
    if (a) {
	this.n = a.n.slice(0);
	this.i = a.i.slice(0);
	this.e = a.e
    } else this.reset()
};
sjcl.hash.sha256.hash = function (a) {
    return (new sjcl.hash.sha256).update(a).finalize()
};
sjcl.hash.sha256.prototype = {
    blockSize: 512,
    reset: function () {
	this.n = this.N.slice(0);
	this.i = [];
	this.e = 0;
	return this
    },
    update: function (a) {
	if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
	var b, c = this.i = sjcl.bitArray.concat(this.i, a);
	b = this.e;
	a = this.e = b + sjcl.bitArray.bitLength(a);
	for (b = 512 + b & -512; b <= a; b += 512) this.D(c.splice(0, 16));
	return this
    },
    finalize: function () {
	var a, b = this.i,
	    c = this.n;
	b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
	for (a = b.length + 2; a & 15; a++) b.push(0);
	b.push(Math.floor(this.e / 4294967296));
	for (b.push(this.e | 0); b.length;) this.D(b.splice(0, 16));
	this.reset();
	return c
    },
    N: [],
    a: [],
    z: function () {
	function a(e) {
	    return (e - Math.floor(e)) * 0x100000000 | 0
	}
	var b = 0,
	    c = 2,
	    d;
	a: for (; b < 64; c++) {
	    for (d = 2; d * d <= c; d++) if (c % d === 0) continue a;
	    if (b < 8) this.N[b] = a(Math.pow(c, 0.5));
	    this.a[b] = a(Math.pow(c, 1 / 3));
	    b++
	}
    },
    D: function (a) {
	var b, c, d = a.slice(0),
	    e = this.n,
	    f = this.a,
	    g = e[0],
	    h = e[1],
	    i = e[2],
	    k = e[3],
	    j = e[4],
	    l = e[5],
	    m = e[6],
	    n = e[7];
	for (a = 0; a < 64; a++) {
	    if (a < 16) b = d[a];
	    else {
		b = d[a + 1 & 15];
		c = d[a + 14 & 15];
		b = d[a & 15] = (b >>> 7 ^ b >>> 18 ^ b >>> 3 ^ b << 25 ^ b << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + d[a & 15] + d[a + 9 & 15] | 0
	    }
	    b = b + n + (j >>> 6 ^ j >>> 11 ^ j >>> 25 ^ j << 26 ^ j << 21 ^ j << 7) + (m ^ j & (l ^ m)) + f[a];
	    n = m;
	    m = l;
	    l = j;
	    j = k + b | 0;
	    k = i;
	    i = h;
	    h = g;
	    g = b + (h & i ^ k & (h ^ i)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0
	}
	e[0] = e[0] + g | 0;
	e[1] = e[1] + h | 0;
	e[2] = e[2] + i | 0;
	e[3] = e[3] + k | 0;
	e[4] = e[4] + j | 0;
	e[5] = e[5] + l | 0;
	e[6] = e[6] + m | 0;
	e[7] = e[7] + n | 0
    }
};
sjcl.mode.ccm = {
    name: "ccm",
    encrypt: function (a, b, c, d, e) {
	var f, g = b.slice(0),
	    h = sjcl.bitArray,
	    i = h.bitLength(c) / 8,
	    k = h.bitLength(g) / 8;
	e = e || 64;
	d = d || [];
	if (i < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (f = 2; f < 4 && k >>> 8 * f; f++);
	if (f < 15 - i) f = 15 - i;
	c = h.clamp(c, 8 * (15 - f));
	b = sjcl.mode.ccm.H(a, b, c, d, e, f);
	g = sjcl.mode.ccm.J(a, g, c, b, e, f);
	return h.concat(g.data, g.tag)
    },
    decrypt: function (a, b, c, d, e) {
	e = e || 64;
	d = d || [];
	var f = sjcl.bitArray,
	    g = f.bitLength(c) / 8,
	    h = f.bitLength(b),
	    i = f.clamp(b, h - e),
	    k = f.bitSlice(b,
	    h - e);
	h = (h - e) / 8;
	if (g < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (b = 2; b < 4 && h >>> 8 * b; b++);
	if (b < 15 - g) b = 15 - g;
	c = f.clamp(c, 8 * (15 - b));
	i = sjcl.mode.ccm.J(a, i, c, k, e, b);
	a = sjcl.mode.ccm.H(a, i.data, c, d, e, b);
	if (!f.equal(i.tag, a)){																//modified to add alert in PassLok
		if(document.getElementById("lockBox").value.slice(0,1) == '~'){						//
			any2key();										//
			document.getElementById("keymsg").innerHTML = "<span style='color:red'>This Key won't unlock the item</span>"
		}else{
			document.getElementById("mainmsg").innerHTML = '<span>Unlocking has Failed</span>';
		}																					//
	throw new sjcl.exception.corrupt("ccm: tag doesn't match")								//
	};																						//
	return i.data
    },
    H: function (a, b, c, d, e, f) {
	var g = [],
	    h = sjcl.bitArray,
	    i = h.k;
	e /= 8;
	if (e % 2 || e < 4 || e > 16) throw new sjcl.exception.invalid("ccm: invalid tag length");
	if (d.length > 0xffffffff || b.length > 0xffffffff) throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
	f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
	f = h.concat(f, c);
	f[3] |= h.bitLength(b) / 8;
	f = a.encrypt(f);
	if (d.length) {
	    c = h.bitLength(d) / 8;
	    if (c <= 65279) g = [h.partial(16, c)];
	    else if (c <= 0xffffffff) g = h.concat([h.partial(16, 65534)], [c]);
	    g = h.concat(g, d);
	    for (d = 0; d < g.length; d += 4) f = a.encrypt(i(f, g.slice(d, d + 4).concat([0, 0, 0])))
	}
	for (d = 0; d < b.length; d += 4) f = a.encrypt(i(f, b.slice(d, d + 4).concat([0, 0, 0])));
	return h.clamp(f, e * 8)
    },
    J: function (a, b, c, d, e, f) {
	var g, h = sjcl.bitArray;
	g = h.k;
	var i = b.length,
	    k = h.bitLength(b);
	c = h.concat([h.partial(8,
	f - 1)], c).concat([0, 0, 0]).slice(0, 4);
	d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
	if (!i) return {
	    tag: d,
	    data: []
	};
	for (g = 0; g < i; g += 4) {
	    c[3]++;
	    e = a.encrypt(c);
	    b[g] ^= e[0];
	    b[g + 1] ^= e[1];
	    b[g + 2] ^= e[2];
	    b[g + 3] ^= e[3]
	}
	return {
	    tag: d,
	    data: h.clamp(b, k)
	}
    }
};
sjcl.mode.ocb2 = {
    name: "ocb2",
    encrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	var g, h = sjcl.mode.ocb2.B,
	    i = sjcl.bitArray,
	    k = i.k,
	    j = [0, 0, 0, 0];
	c = h(a.encrypt(c));
	var l, m = [];
	d = d || [];
	e = e || 64;
	for (g = 0; g + 4 < b.length; g += 4) {
	    l = b.slice(g, g + 4);
	    j = k(j, l);
	    m = m.concat(k(c, a.encrypt(k(c, l))));
	    c = h(c)
	}
	l = b.slice(g);
	b = i.bitLength(l);
	g = a.encrypt(k(c, [0, 0, 0, b]));
	l = i.clamp(k(l.concat([0, 0, 0]), g), b);
	j = k(j, k(l.concat([0, 0, 0]), g));
	j = a.encrypt(k(j, k(c, h(c))));
	if (d.length) j = k(j, f ? d : sjcl.mode.ocb2.pmac(a, d));
	return m.concat(i.concat(l, i.clamp(j, e)))
    },
    decrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	e = e || 64;
	var g = sjcl.mode.ocb2.B,
	    h = sjcl.bitArray,
	    i = h.k,
	    k = [0, 0, 0, 0],
	    j = g(a.encrypt(c)),
	    l, m, n = sjcl.bitArray.bitLength(b) - e,
	    o = [];
	d = d || [];
	for (c = 0; c + 4 < n / 32; c += 4) {
	    l = i(j, a.decrypt(i(j, b.slice(c, c + 4))));
	    k = i(k, l);
	    o = o.concat(l);
	    j = g(j)
	}
	m = n - c * 32;
	l = a.encrypt(i(j, [0, 0, 0, m]));
	l = i(l, h.clamp(b.slice(c),
	m).concat([0, 0, 0]));
	k = i(k, l);
	k = a.encrypt(i(k, i(j, g(j))));
	if (d.length) k = i(k, f ? d : sjcl.mode.ocb2.pmac(a, d));
	if (!h.equal(h.clamp(k, e), h.bitSlice(b, n))) throw new sjcl.exception.corrupt("ocb: tag doesn't match");
	return o.concat(h.clamp(l, m))
    },
    pmac: function (a, b) {
	var c, d = sjcl.mode.ocb2.B,
	    e = sjcl.bitArray,
	    f = e.k,
	    g = [0, 0, 0, 0],
	    h = a.encrypt([0, 0, 0, 0]);
	h = f(h, d(d(h)));
	for (c = 0; c + 4 < b.length; c += 4) {
	    h = d(h);
	    g = f(g, a.encrypt(f(h, b.slice(c, c + 4))))
	}
	b = b.slice(c);
	if (e.bitLength(b) < 128) {
	    h = f(h, d(h));
	    b = e.concat(b, [2147483648 | 0, 0,
	    0, 0])
	}
	g = f(g, b);
	return a.encrypt(f(d(f(h, d(h))), g))
    },
    B: function (a) {
	return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ (a[0] >>> 31) * 135]
    }
};
sjcl.misc.hmac = function (a, b) {
    this.M = b = b || sjcl.hash.sha256;
    var c = [
	[],
	[]
    ],
	d = b.prototype.blockSize / 32;
    this.l = [new b, new b];
    if (a.length > d) a = b.hash(a);
    for (b = 0; b < d; b++) {
	c[0][b] = a[b] ^ 909522486;
	c[1][b] = a[b] ^ 1549556828
    }
    this.l[0].update(c[0]);
    this.l[1].update(c[1])
};
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (a, b) {
    a = (new this.M(this.l[0])).update(a, b).finalize();
    return (new this.M(this.l[1])).update(a).finalize()
};
sjcl.misc.pbkdf2 = function (a, b, c, d, e) {
    c = c || 1E3;
    if (d < 0 || c < 0) throw sjcl.exception.invalid("invalid params to pbkdf2");
    if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
    e = e || sjcl.misc.hmac;
    a = new e(a);
    var f, g, h, i, k = [],
	j = sjcl.bitArray;
    for (i = 1; 32 * k.length < (d || 1); i++) {
	e = f = a.encrypt(j.concat(b, [i]));
	for (g = 1; g < c; g++) {
	    f = a.encrypt(f);
	    for (h = 0; h < f.length; h++) e[h] ^= f[h]
	}
	k = k.concat(e)
    }
    if (d) k = j.clamp(k, d);
    return k
};
sjcl.random = {
    randomWords: function (a, b) {
	var c = [];
	b = this.isReady(b);
	var d;
	if (b === 0) throw new sjcl.exception.notReady("generator isn't seeded");
	else b & 2 && this.U(!(b & 1));
	for (b = 0; b < a; b += 4) {
	    (b + 1) % 0x10000 === 0 && this.L();
	    d = this.w();
	    c.push(d[0], d[1], d[2], d[3])
	}
	this.L();
	return c.slice(0, a)
    },
    setDefaultParanoia: function (a) {
	this.t = a
    },
    addEntropy: function (a, b, c) {
	c = c || "user";
	var d, e, f = (new Date).valueOf(),
	    g = this.q[c],
	    h = this.isReady(),
	    i = 0;
	d = this.G[c];
	if (d === undefined) d = this.G[c] = this.R++;
	if (g === undefined) g = this.q[c] = 0;
	this.q[c] = (this.q[c] + 1) % this.b.length;
	switch (typeof a) {
	    case "number":
		if (b === undefined) b = 1;
		this.b[g].update([d, this.u++, 1, b, f, 1, a | 0]);
		break;
	    case "object":
		c = Object.prototype.toString.call(a);
		if (c === "[object Uint32Array]") {
		    e = [];
		    for (c = 0; c < a.length; c++) e.push(a[c]);
		    a = e
		} else {
		    if (c !== "[object Array]") i = 1;
		    for (c = 0; c < a.length && !i; c++) if (typeof a[c] != "number") i = 1
		}
		if (!i) {
		    if (b === undefined) for (c = b = 0; c < a.length; c++) for (e = a[c]; e > 0;) {
			b++;
			e >>>= 1
		    }
		    this.b[g].update([d, this.u++, 2, b, f, a.length].concat(a))
		}
		break;
	    case "string":
		if (b === undefined) b = a.length;
		this.b[g].update([d, this.u++, 3, b, f, a.length]);
		this.b[g].update(a);
		break;
	    default:
		i = 1
	}
	if (i) throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
	this.j[g] += b;
	this.f += b;
	if (h === 0) {
	    this.isReady() !== 0 && this.K("seeded", Math.max(this.g, this.f));
	    this.K("progress", this.getProgress())
	}
    },
    isReady: function (a) {
	a = this.C[a !== undefined ? a : this.t];
	return this.g && this.g >= a ? this.j[0] > 80 && (new Date).valueOf() > this.O ? 3 : 1 : this.f >= a ? 2 : 0
    },
    getProgress: function (a) {
	a = this.C[a ? a : this.t];
	return this.g >= a ? 1 : this.f > a ? 1 : this.f / a
    },
    startCollectors: function () {
	if (!this.m) {
	    if (window.addEventListener) {
		window.addEventListener("load", this.o, false);
		window.addEventListener("mousemove", this.p, false)
	    } else if (document.attachEvent) {
		document.attachEvent("onload", this.o);
		document.attachEvent("onmousemove", this.p)
	    } else throw new sjcl.exception.bug("can't attach event");
	    this.m = true
	}
    },
    stopCollectors: function () {
	if (this.m) {
	    if (window.removeEventListener) {
		window.removeEventListener("load",
		this.o, false);
		window.removeEventListener("mousemove", this.p, false)
	    } else if (window.detachEvent) {
		window.detachEvent("onload", this.o);
		window.detachEvent("onmousemove", this.p)
	    }
	    this.m = false
	}
    },
    addEventListener: function (a, b) {
	this.r[a][this.Q++] = b
    },
    removeEventListener: function (a, b) {
	var c;
	a = this.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && a[c] === b && d.push(c);
	for (b = 0; b < d.length; b++) {
	    c = d[b];
	    delete a[c]
	}
    },
    b: [new sjcl.hash.sha256],
    j: [0],
    A: 0,
    q: {},
    u: 0,
    G: {},
    R: 0,
    g: 0,
    f: 0,
    O: 0,
    a: [0, 0, 0, 0, 0, 0, 0, 0],
    d: [0, 0, 0, 0],
    s: undefined,
    t: 6,
    m: false,
    r: {
	progress: {},
	seeded: {}
    },
    Q: 0,
    C: [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024],
    w: function () {
	for (var a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
	return this.s.encrypt(this.d)
    },
    L: function () {
	this.a = this.w().concat(this.w());
	this.s = new sjcl.cipher.aes(this.a)
    },
    T: function (a) {
	this.a = sjcl.hash.sha256.hash(this.a.concat(a));
	this.s = new sjcl.cipher.aes(this.a);
	for (a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
    },
    U: function (a) {
	var b = [],
	    c = 0,
	    d;
	this.O = b[0] = (new Date).valueOf() + 3E4;
	for (d = 0; d < 16; d++) b.push(Math.random() * 0x100000000 | 0);
	for (d = 0; d < this.b.length; d++) {
	    b = b.concat(this.b[d].finalize());
	    c += this.j[d];
	    this.j[d] = 0;
	    if (!a && this.A & 1 << d) break
	}
	if (this.A >= 1 << this.b.length) {
	    this.b.push(new sjcl.hash.sha256);
	    this.j.push(0)
	}
	this.f -= c;
	if (c > this.g) this.g = c;
	this.A++;
	this.T(b)
    },
    p: function (a) {
	sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse")
    },
    o: function () {
	sjcl.random.addEntropy((new Date).valueOf(), 2, "loadtime")
    },
    K: function (a, b) {
	var c;
	a = sjcl.random.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && d.push(a[c]);
	for (c = 0; c < d.length; c++) d[c](b)
    }
};
try {
    var s = new Uint32Array(32);
    crypto.getRandomValues(s);
    sjcl.random.addEntropy(s, 1024, "crypto['getRandomValues']")
} catch (t) {}
sjcl.json = {
    defaults: {
	v: 1,
	iter: 1E3,
	ks: 128,
	ts: 64,
	mode: "ccm",
	adata: "",
	cipher: "aes"
    },
    encrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json,
	    f = e.c({
		iv: sjcl.random.randomWords(4, 0)
	    }, e.defaults),
	    g;
	e.c(f, c);
	c = f.adata;
	if (typeof f.salt === "string") f.salt = sjcl.codec.base64.toBits(f.salt);
	if (typeof f.iv === "string") f.iv = sjcl.codec.base64.toBits(f.iv);
	if (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || typeof a === "string" && f.iter <= 100 || f.ts !== 64 && f.ts !== 96 && f.ts !== 128 || f.ks !== 128 && f.ks !== 192 && f.ks !== 0x100 || f.iv.length < 2 || f.iv.length > 4) throw new sjcl.exception.invalid("json encrypt: invalid parameters");
	if (typeof a === "string") {
	    g = sjcl.misc.cachedPbkdf2(a, f);
	    a = g.key.slice(0, f.ks / 32);
	    f.salt = g.salt
	}
	if (typeof b === "string") b = sjcl.codec.utf8String.toBits(b);
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	g = new sjcl.cipher[f.cipher](a);
	e.c(d, f);
	d.key = a;
	f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
	return e.encode(f)
    },
    decrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json;
	b = e.c(e.c(e.c({}, e.defaults), e.decode(b)),
	c, true);
	var f;
	c = b.adata;
	if (typeof b.salt === "string") b.salt = sjcl.codec.base64.toBits(b.salt);
	if (typeof b.iv === "string") b.iv = sjcl.codec.base64.toBits(b.iv);
	if (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || typeof a === "string" && b.iter <= 100 || b.ts !== 64 && b.ts !== 96 && b.ts !== 128 || b.ks !== 128 && b.ks !== 192 && b.ks !== 0x100 || !b.iv || b.iv.length < 2 || b.iv.length > 4) throw new sjcl.exception.invalid("json decrypt: invalid parameters");
	if (typeof a === "string") {
	    f = sjcl.misc.cachedPbkdf2(a, b);
	    a = f.key.slice(0, b.ks / 32);
	    b.salt = f.salt
	}
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	f = new sjcl.cipher[b.cipher](a);
	c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
	e.c(d, b);
	d.key = a;
	return sjcl.codec.utf8String.fromBits(c)
    },
    encode: function (a) {
	var b, c = "{",
	    d = "";
	for (b in a) if (a.hasOwnProperty(b)) {
	    if (!b.match(/^[a-z0-9]+$/i)) throw new sjcl.exception.invalid("json encode: invalid property name");
	    c += d + '"' + b + '":';
	    d = ",";
	    switch (typeof a[b]) {
		case "number":
		case "boolean":
		    c += a[b];
		    break;
		case "string":
		    c += '"' + escape(a[b]) + '"';
		    break;
		case "object":
		    c += '"' + sjcl.codec.base64.fromBits(a[b], 1) + '"';
		    break;
		default:
		    throw new sjcl.exception.bug("json encode: unsupported type");
	    }
	}
	return c + "}"
    },
    decode: function (a) {
	a = a.replace(/\s/g, "");
	if (!a.match(/^\{.*\}$/)) throw new sjcl.exception.invalid("json decode: this isn't json!");
	a = a.replace(/^\{|\}$/g, "").split(/,/);
	var b = {}, c, d;
	for (c = 0; c < a.length; c++) {
	    if (!(d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))) throw new sjcl.exception.invalid("json decode: this isn't json!");
	    b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4])
	}
	return b
    },
    c: function (a, b, c) {
	if (a === undefined) a = {};
	if (b === undefined) return a;
	var d;
	for (d in b) if (b.hasOwnProperty(d)) {
	    if (c && a[d] !== undefined && a[d] !== b[d]) throw new sjcl.exception.invalid("required parameter overridden");
	    a[d] = b[d]
	}
	return a
    },
    W: function (a, b) {
	var c = {}, d;
	for (d in a) if (a.hasOwnProperty(d) && a[d] !== b[d]) c[d] = a[d];
	return c
    },
    V: function (a, b) {
	var c = {}, d;
	for (d = 0; d < b.length; d++) if (a[b[d]] !== undefined) c[b[d]] = a[b[d]];
	return c
    }
};
sjcl.encrypt = sjcl.json.encrypt;
sjcl.decrypt = sjcl.json.decrypt;
sjcl.misc.S = {};
sjcl.misc.cachedPbkdf2 = function (a, b) {
    var c = sjcl.misc.S,
	d;
    b = b || {};
    d = b.iter || 1E3;
    c = c[a] = c[a] || {};
    d = c[d] = c[d] || {
	firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)
    };
    c = b.salt === undefined ? d.firstSalt : b.salt;
    d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
    return {
	key: d[c].slice(0),
	salt: c.slice(0)
    }
};

//SHA512.js begins (also from SJCL)
/** @fileOverview Javascript SHA-512 implementation.
 *
 * This implementation was written for CryptoJS by Jeff Mott and adapted for
 * SJCL by Stefan Thomas.
 *
 * CryptoJS (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Released with New BSD License
 */

/**
 * Context for a SHA-512 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 512 bits.
 */
sjcl.hash.sha512 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha512.hash = function (data) {
  return (new sjcl.hash.sha512()).update(data).finalize();
};

sjcl.hash.sha512.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 1024,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 1024+ol & -1024; i <= nl; i+= 1024) {
      this._block(b.splice(0,32));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

    // Round out the buffer to a multiple of 32 words, less the 4 length words.
    for (i = b.length + 4; i & 31; i++) {
      b.push(0);
    }

    // append the length
    b.push(0);
    b.push(0);
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,32));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-512 initialization vector, to be precomputed.
   * @private
   */
  _init:[],

  /**
   * Least significant 24 bits of SHA512 initialization values.
   *
   * Javascript only has 53 bits of precision, so we compute the 40 most
   * significant bits and add the remaining 24 bits as constants.
   *
   * @private
   */
  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],

   /**
   * The SHA-512 hash key, to be precomputed.
   * @private
   */
  _key:[],

  /**
   * Least significant 24 bits of SHA512 key values.
   * @private
   */
  _keyr:
  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,
   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,
   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,
   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,
   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,
   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,
   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,
   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,
   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,
   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],

  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    // XXX: This code is for precomputing the SHA256 constants, change for
    //      SHA512 and re-enable.
    var i = 0, prime = 2, factor;

    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }
    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }

    outer: for (; i<80; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }

      if (i<8) {
        this._init[i*2] = frac(Math.pow(prime, 1/2));
        this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];
      }
      this._key[i*2] = frac(Math.pow(prime, 1/3));
      this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];
      i++;
    }
  },

  /**
   * Perform one cycle of SHA-512.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {
    var i, wrh, wrl,
        w = words.slice(0),
        h = this._h,
        k = this._key,
        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],
        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],
        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],
        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];

    // Working variables
    var ah = h0h, al = h0l, bh = h1h, bl = h1l,
        ch = h2h, cl = h2l, dh = h3h, dl = h3l,
        eh = h4h, el = h4l, fh = h5h, fl = h5l,
        gh = h6h, gl = h6l, hh = h7h, hl = h7l;

    for (i=0; i<80; i++) {
      // load up the input word for this round
      if (i<16) {
        wrh = w[i * 2];
        wrl = w[i * 2 + 1];
      } else {
        // Gamma0
        var gamma0xh = w[(i-15) * 2];
        var gamma0xl = w[(i-15) * 2 + 1];
        var gamma0h =
          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^
          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^
           (gamma0xh >>> 7);
        var gamma0l =
          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^
          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^
          ((gamma0xh << 25) | (gamma0xl >>> 7));

        // Gamma1
        var gamma1xh = w[(i-2) * 2];
        var gamma1xl = w[(i-2) * 2 + 1];
        var gamma1h =
          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^
          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^
           (gamma1xh >>> 6);
        var gamma1l =
          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^
          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^
          ((gamma1xh << 26) | (gamma1xl >>> 6));

        // Shortcuts
        var wr7h = w[(i-7) * 2];
        var wr7l = w[(i-7) * 2 + 1];

        var wr16h = w[(i-16) * 2];
        var wr16l = w[(i-16) * 2 + 1];

        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)
        wrl = gamma0l + wr7l;
        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);
        wrl += gamma1l;
        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);
        wrl += wr16l;
        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);
      }

      w[i*2]     = wrh |= 0;
      w[i*2 + 1] = wrl |= 0;

      // Ch
      var chh = (eh & fh) ^ (~eh & gh);
      var chl = (el & fl) ^ (~el & gl);

      // Maj
      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

      // Sigma0
      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));

      // Sigma1
      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));
      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));

      // K(round)
      var krh = k[i*2];
      var krl = k[i*2+1];

      // t1 = h + sigma1 + ch + K(round) + W(round)
      var t1l = hl + sigma1l;
      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
      t1l += chl;
      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
      t1l += krl;
      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);
      t1l += wrl;
      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);

      // t2 = sigma0 + maj
      var t2l = sigma0l + majl;
      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

      // Update working variables
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = (dl + t1l) | 0;
      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = (t1l + t2l) | 0;
      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
    }

    // Intermediate hash
    h0l = h[1] = (h0l + al) | 0;
    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;
    h1l = h[3] = (h1l + bl) | 0;
    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;
    h2l = h[5] = (h2l + cl) | 0;
    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;
    h3l = h[7] = (h3l + dl) | 0;
    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
    h4l = h[9] = (h4l + el) | 0;
    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;
    h5l = h[11] = (h5l + fl) | 0;
    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;
    h6l = h[13] = (h6l + gl) | 0;
    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;
    h7l = h[15] = (h7l + hl) | 0;
    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;
  }
};
//SHA512.js ends

//SJCL-SCRYPT.JS, by joe-invincible begins
var B, X, SIZE_MAX = Math.pow(2, 32) - 1;

sjcl.misc.scrypt = function(passwd, salt, N, r, p, dkLen) {

  function flipEndian(x) {
    var first = x & 0xFF;
    var second = (x >>> 8) & 0xFF;
    var third = (x >>> 16) & 0xFF;
    var fourth = (x >>> 24) & 0xFF;
    return (first << 24) | (second << 16) | (third << 8) | fourth;
  }
  
  function sanityCheck() {
    if (r * p >= Math.pow(2, 30)) {
      throw "The parameters r, p must satisfy r * p < 2^30";
    }
    if ((N < 2) || (N & (N - 1) != 0)) {
      throw "The parameter N must be a power of 2.";
    }
    SIZE_MAX = Math.pow(2, 32) - 1;
    if (N > SIZE_MAX / 128 / r) {
    throw "N too big.";
    }
    if (r > SIZE_MAX / 128 / p) {
      throw "r too big.";
    }
  }

  function scrypt(passwd, salt, N, r, p, dkLen) {
    B = sjcl.misc.pbkdf2(passwd, salt, 1, p * 128 * r * 8);
    var V = []; 
    var XY = [];
    for (var i = 0; i < p; i++) {
      smix(B, i * 128 * r, r, N, V, XY);
    }
    return sjcl.misc.pbkdf2(passwd, B, 1, dkLen * 8);
  };

  function salsa20_8(B) {

    function R(a, b) {
      return (a << b) | (a >>> (32 - b));
    }
    
    var B32 = [];
    for (var i = 0; i < 16; i++) {
      B32[i] = flipEndian(B[i]);  
    }
  
    var x = [];
    for (var i = 0; i < 16; i++) {
      x[i] = B32[i] | 0;
    }
  
    for (i = 8; i > 0; i -= 2) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }
  
    for (var i = 0; i < 16; i++) {
      B32[i] = (B32[i] + x[i]) | 0;
    }
    
    for (var i = 0; i < 16; i++) {
      B[i] = flipEndian(B32[i]);  
    }
  
    return B;
  }

  function blockxor(S, Si, D, Di, len) {
    len /= 4;
    Si /= 4;
    Di /= 4;
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i] | 0;
    }
  }
  
  function blockcopy(S, Si, D, Di, len) {
    len /= 4;
    Si /= 4;
    Di /= 4;
    for (var i = 0; i < len; i++) {
      D[Di + i] = S[Si + i] | 0;
    }
  }
  
  function blockmix_salsa8(BY, Bi, Yi, r) {
    X = [];
    var i;
  
    blockcopy(BY, Bi + (2 * r - 1) * 64, X, 0, 64);
  
    for (i = 0; i < 2 * r; i++) {
        blockxor(BY, i * 64, X, 0, 64);
        salsa20_8(X);
        blockcopy(X, 0, BY, Yi + (i * 64), 64);
    }
  
    for (i = 0; i < r; i++) {
        blockcopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64);
    }
  
    for (i = 0; i < r; i++) {
        blockcopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64);
    }
  }
  
  function smix(B, Bi, r, N, V, XY) {
    var Xi = 0;
    var Yi = 128 * r;
    var i;
  
    blockcopy(B, Bi, XY, Xi, Yi);
  
    for (i = 0; i < N; i++) {
      blockcopy(XY, Xi, V, i * Yi, Yi);
      blockmix_salsa8(XY, Xi, Yi, r);
    }
  
    for (i = 0; i < N; i++) {
      var j = integerify(XY, Xi, r) & (N - 1);
      blockxor(V, j * Yi, XY, Xi, Yi);
      blockmix_salsa8(XY, Xi, Yi, r);
    }
  
    blockcopy(XY, Xi, B, Bi, Yi);
  }
  
  function integerify(B, Bi, r) {
    Bi = Bi + (2 * r - 1) * 64;
    return flipEndian(B[Bi / 4]);
  }

  sanityCheck();
  return scrypt(passwd, salt, N, r, p, dkLen);
}
//SJCL-SCRYPT.JS ends

//BN.js begins (also from SJCL)
/**
 * Constructs a new bignum from another bignum, a number or a hex string.
 */
sjcl.bn = function(it) {
  this.initWith(it);
};

sjcl.bn.prototype = {
  radix: 24,
  maxMul: 8,
  _class: sjcl.bn,
  
  copy: function() {
    return new this._class(this);
  },

  /**
   * Initializes this with it, either as a bn, a number, or a hex string.
   */
  initWith: function(it) {
    var i=0, k, n, l;
    switch(typeof it) {
    case "object":
      this.limbs = it.limbs.slice(0);
      break;
      
    case "number":
      this.limbs = [it];
      this.normalize();
      break;
      
    case "string":
      it = it.replace(/^0x/, '');
      this.limbs = [];
      // hack
      k = this.radix / 4;
      for (i=0; i < it.length; i+=k) {
	this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));
      }
      break;

    default:
      this.limbs = [0];
    }
    return this;
  },

  /**
   * Returns true if "this" and "that" are equal.  Calls fullReduce().
   * Equality test is in constant time.
   */
  equals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var difference = 0, i;
    this.fullReduce();
    that.fullReduce();
    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {
      difference |= this.getLimb(i) ^ that.getLimb(i);
    }
    return (difference === 0);
  },
  
  /**
   * Get the i'th limb of this, zero if i is too large.
   */
  getLimb: function(i) {
    return (i >= this.limbs.length) ? 0 : this.limbs[i];
  },
  
  /**
   * Constant time comparison function.
   * Returns 1 if this >= that, or zero otherwise.
   */
  greaterEquals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var less = 0, greater = 0, i, a, b;
    i = Math.max(this.limbs.length, that.limbs.length) - 1;
    for (; i>= 0; i--) {
      a = this.getLimb(i);
      b = that.getLimb(i);
      greater |= (b - a) & ~less;
      less |= (a - b) & ~greater;
    }
    return (greater | ~less) >>> 31;
  },
  
  /**
   * Convert to a hex string.
   */
  toString: function() {
    this.fullReduce();
    var out="", i, s, l = this.limbs;
    for (i=0; i < this.limbs.length; i++) {
      s = l[i].toString(16);
      while (i < this.limbs.length - 1 && s.length < 6) {
	s = "0" + s;
      }
      out = s + out;
    }
    return "0x"+out;
  },
  
  /** this += that.  Does not normalize. */
  addM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] += ll[i];
    }
    return this;
  },
  
  /** this *= 2.  Requires normalized; ends up normalized. */
  doubleM: function() {
    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;
    for (i=0; i<l.length; i++) {
      tmp = l[i];
      tmp = tmp+tmp+carry;
      l[i] = tmp & m;
      carry = tmp >> r;
    }
    if (carry) {
      l.push(carry);
    }
    return this;
  },
  
  /** this /= 2, rounded down.	Requires normalized; ends up normalized. */
  halveM: function() {
    var i, carry=0, tmp, r=this.radix, l=this.limbs;
    for (i=l.length-1; i>=0; i--) {
      tmp = l[i];
      l[i] = (tmp+carry)>>1;
      carry = (tmp&1) << r;
    }
    if (!l[l.length-1]) {
      l.pop();
    }
    return this;
  },

  /** this -= that.  Does not normalize. */
  subM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] -= ll[i];
    }
    return this;
  },
  
  mod: function(that) {
    that = new sjcl.bn(that).normalize(); // copy before we begin
    var out = new sjcl.bn(this).normalize(), ci=0;
    
    for (; out.greaterEquals(that); ci++) {

      that.doubleM();
    }
    for (; ci > 0; ci--) {
      that.halveM();
      if (out.greaterEquals(that)) {
	out.subM(that).normalize();
      }
    }
    return out.trim();
  },
  
  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */
  inverseMod: function(p) {
    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;
    
    if (!(p.limbs[0] & 1)) {
      throw (new sjcl.exception.invalid("inverseMod: p must be odd"));
    }
    
    // invariant: y is odd
    do {
      if (x.limbs[0] & 1) {
	if (!x.greaterEquals(y)) {
	  // x < y; swap everything
	  tmp = x; x = y; y = tmp;
	  tmp = a; a = b; b = tmp;
	}
	x.subM(y);
	x.normalize();
	
	if (!a.greaterEquals(b)) {
	  a.addM(p);
	}
	a.subM(b);
      }
      
      // cut everything in half
      x.halveM();
      if (a.limbs[0] & 1) {
	a.addM(p);
      }
      a.normalize();
      a.halveM();
      
      // check for termination: x ?= 0
      for (i=nz=0; i<x.limbs.length; i++) {
	nz |= x.limbs[i];
      }
    } while(nz);
    
    if (!y.equals(1)) {
      throw (new sjcl.exception.invalid("inverseMod: p and x must be relatively prime"));
    }
    
    return b;
  },
  
  /** this + that.  Does not normalize. */
  add: function(that) {
    return this.copy().addM(that);
  },

  /** this - that.  Does not normalize. */
  sub: function(that) {
    return this.copy().subM(that);
  },
  
  /** this * that.  Normalizes and reduces. */
  mul: function(that) {
    if (typeof(that) === "number") { that = new this._class(that); }
    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;

    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {
      c[i] = 0;
    }
    for (i=0; i<al; i++) {
      ai = a[i];
      for (j=0; j<bl; j++) {
	c[i+j] += ai * b[j];
      }
     
      if (!--ii) {
	ii = this.maxMul;
	out.cnormalize();
      }
    }
    return out.cnormalize().reduce();
  },

  /** this ^ 2.  Normalizes and reduces. */
  square: function() {
    return this.mul(this);
  },

  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */
  power: function(l) {
    if (typeof(l) === "number") {
      l = [l];
    } else if (l.limbs !== undefined) {
      l = l.normalize().limbs;
    }
    var i, j, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
	if (l[i] & (1<<j)) {
	  out = out.mul(pow);
	}
	pow = pow.square();
      }
    }
    
    return out;
  },

  /** this * that mod N */
  mulmod: function(that, N) {
    return this.mod(N).mul(that.mod(N)).mod(N);
  },

  /** this ^ x mod N */
  powermod: function(x, N) {
    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);
    while (true) {
      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }
      k.halveM();
      if (k.equals(0)) { break; }
      a = a.mulmod(a, N);
    }
    return result.normalize().reduce();
  },

  trim: function() {
    var l = this.limbs, p;
    do {
      p = l.pop();
    } while (l.length && p === 0);
    l.push(p);
    return this;
  },
  
  /** Reduce mod a modulus.  Stubbed for subclassing. */
  reduce: function() {
    return this;
  },

  /** Reduce and normalize. */
  fullReduce: function() {
    return this.normalize();
  },
  
  /** Propagate carries. */
  normalize: function() {
    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {
      l = (limbs[i]||0) + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    if (carry === -1) {
      limbs[i-1] -= this.placeVal;
    }
    return this;
  },

  /** Constant-time normalize. Does not allocate additional space. */
  cnormalize: function() {
    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll-1; i++) {
      l = limbs[i] + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    limbs[i] += carry;
    return this;
  },
  
  /** Serialize to a bit array */
  toBits: function(len) {
    this.fullReduce();
    len = len || this.exponent || this.limbs.length * this.radix;
    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,
	out = [w.partial(e, this.getLimb(i))];
    for (i--; i >= 0; i--) {
      out = w.concat(out, [w.partial(this.radix, this.getLimb(i))]);
    }
    return out;
  },
  
  /** Return the length in bits, rounded up to the nearest byte. */
  bitLength: function() {
    this.fullReduce();
    var out = this.radix * (this.limbs.length - 1),
	b = this.limbs[this.limbs.length - 1];
    for (; b; b >>= 1) {
      out ++;
    }
    return out+7 & -8;
  }
};

sjcl.bn.fromBits = function(bits) {
  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,
      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;
  
  words[0] = w.extract(bits, 0, e);
  for (; e < l; e += t.radix) {
    words.unshift(w.extract(bits, e, t.radix));
  }

  out.limbs = words;
  return out;
};

sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;

/**
 * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,
 * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.
 */
sjcl.bn.pseudoMersennePrime = function(exponent, coeff) {
  function p(it) {
    this.initWith(it);
    /*if (this.limbs[this.modOffset]) {
      this.reduce();
    }*/
  }

  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;
  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);
  ppr.exponent = exponent;
  ppr.offset = [];
  ppr.factor = [];
  ppr.minOffset = mo;
  ppr.fullMask = 0;
  ppr.fullOffset = [];
  ppr.fullFactor = [];
  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));
  
  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);

  for (i=0; i<coeff.length; i++) {
    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);
    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);
    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);
    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);
    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));
    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative
  }
  ppr._class = p;
  ppr.modulus.cnormalize();

  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p. */
  ppr.reduce = function() {
    var i, k, l, mo = this.modOffset, limbs = this.limbs, aff, off = this.offset, ol = this.offset.length, fac = this.factor, ll;

    i = this.minOffset;
    while (limbs.length > mo) {
      l = limbs.pop();
      ll = limbs.length;
      for (k=0; k<ol; k++) {
	limbs[ll+off[k]] -= fac[k] * l;
      }
      
      i--;
      if (!i) {
	limbs.push(0);
	this.cnormalize();
	i = this.minOffset;
      }
    }
    this.cnormalize();

    return this;
  };
  
  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {
    var limbs = this.limbs, i = limbs.length - 1, k, l;
    this.reduce();
    if (i === this.modOffset - 1) {
      l = limbs[i] & this.fullMask;
      limbs[i] -= l;
      for (k=0; k<this.fullOffset.length; k++) {
	limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;
      }
      this.normalize();
    }
  };

  /** mostly constant-time, very expensive full reduction. */
  ppr.fullReduce = function() {
    var greater, i;
    // massively above the modulus, may be negative
    
    this._strongReduce();
    // less than twice the modulus, may be negative

    this.addM(this.modulus);
    this.addM(this.modulus);
    this.normalize();
    // probably 2-3x the modulus
    
    this._strongReduce();
    // less than the power of 2.  still may be more than
    // the modulus

    // HACK: pad out to this length
    for (i=this.limbs.length; i<this.modOffset; i++) {
      this.limbs[i] = 0;
    }
    
    // constant-time subtract modulus
    greater = this.greaterEquals(this.modulus);
    for (i=0; i<this.limbs.length; i++) {
      this.limbs[i] -= this.modulus.limbs[i] * greater;
    }
    this.cnormalize();

    return this;
  };

  ppr.inverse = function() {
    return (this.power(this.modulus.sub(2)));
  };

  p.fromBits = sjcl.bn.fromBits;

  return p;
};

// a small Mersenne prime
sjcl.bn.prime = {
  // NIST primes
  p192: sjcl.bn.pseudoMersennePrime(192, [[0,-1],[64,-1]]),
  p224: sjcl.bn.pseudoMersennePrime(224, [[0,1],[96,-1]]),
  p256: sjcl.bn.pseudoMersennePrime(256, [[0,-1],[96,1],[192,1],[224,-1]]),
  p384: sjcl.bn.pseudoMersennePrime(384, [[0,-1],[32,1],[96,-1],[128,-1]]),
  p521: sjcl.bn.pseudoMersennePrime(521, [[0,-1]])
};

sjcl.bn.random = function(modulus, paranoia) {
  if (typeof modulus !== "object") { modulus = new sjcl.bn(modulus); }
  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();
  while (true) {
    // get a sequence whose first digits make sense
    do {
      words = sjcl.random.randomWords(l, paranoia);
      if (words[l-1] < 0) { words[l-1] += 0x100000000; }
    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));
    words[l-1] %= m;

    // mask off all the limbs
    for (i=0; i<l-1; i++) {
      words[i] &= modulus.radixMask;
    }

    // check the rest of the digitssj
    out.limbs = words;
    if (!out.greaterEquals(modulus)) {
      return out;
    }
  }
};

//ECC.js begins
//F. Ruiz: I added the 521-bit curve, took out elGamal etc. at the end, replaced by my own functions. Modifications are noted)

sjcl.ecc = {};

/**
 * Represents a point on a curve in affine coordinates.
 * @constructor
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 * @param {bigInt} x The x coordinate.
 * @param {bigInt} y The y coordinate.
 */
sjcl.ecc.point = function(curve,x,y) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.point.prototype = {
  toJac: function() {
    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));
  },

  mult: function(k) {
    return this.toJac().mult(k, this).toAffine();
  },
  
  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k, k2, affine2) {
    return this.toJac().mult2(k, this, k2, affine2).toAffine();
  },
  
  multiples: function() {
    var m, i, j;
    if (this._multiples === undefined) {
      j = this.toJac().doubl();
      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];
      for (i=3; i<16; i++) {
	j = j.add(this);
	m.push(j.toAffine());
      }
    }
    return this._multiples;
  },

  isValid: function() {
    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));
  },

  toBits: function() {
    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());
  }
};

/**
 * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which
 * will be converted to bigInts).
 *
 * @constructor
 * @param {bigInt/string} x The x coordinate.
 * @param {bigInt/string} y The y coordinate.
 * @param {bigInt/string} z The z coordinate.
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 */
sjcl.ecc.pointJac = function(curve, x, y, z) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.z = z;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.pointJac.prototype = {
  /**
   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.
   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.
   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.
   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. 
   */
  add: function(T) {
    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;
    if (S.curve !== T.curve) {
      throw("sjcl.ecc.add(): Points must be on the same curve to add them!");
    }

    if (S.isIdentity) {
      return T.toJac();
    } else if (T.isIdentity) {
      return S;
    }

    sz2 = S.z.square();
    c = T.x.mul(sz2).subM(S.x);

    if (c.equals(0)) {
      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {
	// same point
	return S.doubl();
      } else {
	// inverses
	return new sjcl.ecc.pointJac(S.curve);
      }
    }
    
    d = T.y.mul(sz2.mul(S.z)).subM(S.y);
    c2 = c.square();

    x1 = d.square();
    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );
    x  = x1.subM(x2);

    y1 = S.x.mul(c2).subM(x).mul(d);
    y2 = S.y.mul(c.square().mul(c));
    y  = y1.subM(y2);

    z  = S.z.mul(c);

    return new sjcl.ecc.pointJac(this.curve,x,y,z);
  },
  
  /**
   * doubles this point.
   * @return {sjcl.ecc.pointJac} The doubled point.
   */
  doubl: function() {
    if (this.isIdentity) { return this; }

    var
      y2 = this.y.square(),
      a  = y2.mul(this.x.mul(4)),
      b  = y2.square().mul(8),
      z2 = this.z.square(),
      c  = this.x.sub(z2).mul(3).mul(this.x.add(z2)),
      x  = c.square().subM(a).subM(a),
      y  = a.sub(x).mul(c).subM(b),
      z  = this.y.add(this.y).mul(this.z);
    return new sjcl.ecc.pointJac(this.curve, x, y, z);
  },

  /**
   * Returns a copy of this point converted to affine coordinates.
   * @return {sjcl.ecc.point} The converted point.
   */  
  toAffine: function() {
    if (this.isIdentity || this.z.equals(0)) {
      return new sjcl.ecc.point(this.curve);
    }
    var zi = this.z.inverse(), zi2 = zi.square();
    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());
  },
  
  /**
   * Multiply this point by k and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.
   */
  mult: function(k, affine) {
    if (typeof(k) === "number") {
      k = [k];
    } else if (k.limbs !== undefined) {
      k = k.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();

    for (i=k.length-1; i>=0; i--) {
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
	out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);
      }
    }
    
    return out;
  },
  
/**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k1, affine, k2, affine2) {
    if (typeof(k1) === "number") {
      k1 = [k1];
    } else if (k1.limbs !== undefined) {
      k1 = k1.normalize().limbs;
    }
    
    if (typeof(k2) === "number") {
      k2 = [k2];
    } else if (k2.limbs !== undefined) {
      k2 = k2.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),
        m2 = affine2.multiples(), l1, l2;

    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {
      l1 = k1[i] | 0;
      l2 = k2[i] | 0;
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);
      }
    }
    
    return out;
  },
  
  isValid: function() {
    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);
    return this.y.square().equals(
	    this.curve.b.mul(z6).add(this.x.mul(
	      this.curve.a.mul(z4).add(this.x.square()))));
  }
};

/**
 * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.
 *
 * @constructor
 * @param {bigInt} p The prime modulus.
 * @param {bigInt} r The prime order of the curve.
 * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).
 * @param {bigInt} x The x coordinate of a base point of the curve.
 * @param {bigInt} y The y coordinate of a base point of the curve.
 */
sjcl.ecc.curve = function(Field, r, a, b, x, y) {
  this.field = Field;
  this.r = Field.prototype.modulus.sub(r);
  this.a = new Field(a);
  this.b = new Field(b);
  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));
};

sjcl.ecc.curve.prototype.fromBits = function (bits) {
  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,
      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),
			    this.field.fromBits(w.bitSlice(bits, l, 2*l)));
  if (!p.isValid()) {															//modified to add alert in PassLok
	document.getElementById("mainmsg").innerHTML = '<span>Invalid Lock</span>';	//
    throw new sjcl.exception.corrupt("not on the curve!");						//
  }																				//
  return p;
};

//F. Ruiz: Added the NIST 521-bit elliptic curve parameters, removed the other curves since they are not used in PassLok

sjcl.ecc.curves = {
	
  c521: new sjcl.ecc.curve(				//these parameters are my addition to ecc.js
	sjcl.bn.prime.p521,
	"0x5AE79787C40D069948033FEB708F65A2FC44A36477663B851449048E16EC79BF6",
	- 3,
"0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00",
"0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66",
"0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};

//End of SJCL code, some of its elGamal, ECDSA code is used in the functions in PassLokhead.js

//Now the ORIGINAL PASSLOK CODE BEGINS

//set global variables for lock DB functions
if(!("lockDB" in localStorage)) localStorage["lockDB"] = "{}";  //initialize lockDB, which is a nested object
var lockDB = JSON.parse(localStorage.lockDB);					//database in Object form
var lockNames = [''].concat(Object.keys(lockDB));				//array for finding lock names

//function to test key strength and come up with appropriate key stretching
function keyStrength(pwd,display) {
var iter = 6000;
var keymsg = document.getElementById("keymsg");
var decoymsg = document.getElementById("decoymsg");
var intromsg = document.getElementById("intromsg");
var strongRegex = new RegExp("^(?=.{7,})(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[^a-zA-Z0-9]).*$", "g");
var goodRegex = new RegExp("^(?=.{7,})(((?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]))|((?=.*[^a-zA-Z0-9])(?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]))).*$", "g");
var mediumRegex = new RegExp("^(?=.{7,})(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[^a-zA-Z0-9]))|((?=.*[A-Z])(?=.*[^a-zA-Z0-9]))|((?=.*[0-9])(?=.*[^a-zA-Z0-9]))).*$", "g");
var enoughRegex = new RegExp("(?=.{7,}).*", "g");
	pwd = pwd.replace(/^\d+/,'').replace(/\d+$/,'');									//no credit for initial and trailing numbers
	pwd = pwd.replace(/^[a-zA-Z]/,'');													//no credit for initial letter, small or capital
	pwd = pwd.replace(/\s/g,'');														//no credit for spaces
if (pwd.length==0) {
var msg = "&nbsp";
} else if (false === enoughRegex.test(pwd)) {
var msg = '<span style="color:magenta"> Terrible!</span>';								//less than 8 good characters
iter = 6000;
} else if (strongRegex.test(pwd)) {
var msg = '<span style="color:blue">  Great!</span>';									//at least 8 comprising all: lowercase, caps, numbers, and sp chars
iter = 2;
} else if (goodRegex.test(pwd)) {
var msg = '<span style="color:green">  Good!</span>';									//at least 8 of three kinds: lowercase, caps, numbers, and sp chars
iter = 500;
} else if (mediumRegex.test(pwd)) {
var msg = '<span style="color:orange">  Medium</span>';									//at least 8 of either two of: lowercase, caps, numbers, sp chars
iter = 1500;
} else {
var msg = '<span style="color:red">  Weak!</span>';										//at least 8 of one kind of characters
iter = 2500;
};
if(display){
	if(document.getElementById("keyscr").style.display=="block") keymsg.innerHTML = msg;
	if(document.getElementById("decoyIn").style.display=="block") decoymsg.innerHTML = msg;
	if(document.getElementById("introscr").style.display=="block") intromsg.innerHTML = msg;
}
return iter
};

//if secret Key box is empty, this displays a warning, otherwise display Lock in main box. Second time sends Lock to directory.
function fillkeys(){
	var learnOn = document.getElementById("learnmode").checked;
	var keymsg = document.getElementById("keymsg"),				//for displaying messages above key box
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var keystr = document.getElementById('pwd').value.trim();				//cut trailing spaces	
	if(keystr==""){												//if the key box is empty, display a warning
		keymsg.innerHTML = '<span style="color:red">Please write your Key in the box</span>';
		throw("no Key");	
	} else {													//replace the main box with Lock made from the key box
		if (learnOn){
			var reply = confirm("The Lock matching the Key in this box will be placed in the main box, replacing its contents. Cancel if this is not what you want.");
			if(reply===false) throw("lock canceled");
		};
		if (striptags(document.getElementById('mainBox').value).length == 87){						//2nd time: send Lock to directory
			loadLockDir();
			var lockdirframe = document.getElementById('lockdirframe');
			lockdirframe.contentWindow.postMessage(document.getElementById('mainBox').value, 'https://passlok.com');
			lockdirframe.onload = function() {
    			lockdirframe.contentWindow.postMessage(document.getElementById('mainBox').value, 'https://passlok.com');		//so that the Lock directory gets the Lock, too
			};
			key2any();
			document.getElementById('mainscr').style.display = "none";
			document.getElementById('lockscr').style.display = "none";
			document.getElementById('lockdir').style.display = "block";
			return
		}
		showpub(keystr);
		keymsg.innerHTML = 'Lock in the main box';
		mainmsg.innerHTML = 'This is the Lock matching your Key. To post it on the general directory, click <strong>myKey</strong>, and then <strong>Make Lock</strong>';
	};	
};

//displays the public key on the main screen
function showpub(secstr){
	var pubstr = makepub(secstr);
	if (document.getElementById("notags").checked === false){
		document.getElementById('mainBox').value = "PL17lok=" + pubstr + "=PL17lok";
	}else{
		document.getElementById('mainBox').value = pubstr;
	}
};

//makes the public string of a private string
function makepub(secstr){
	var curve = sjcl.ecc.curves["c521"],						//make curve object
		sec = toexponent(secstr),								//retrieve Key, correctly formatted as an EC exponent
	    pub = curve.G.mult(sec),								//make public key or Lock
		pubstr = sjcl.codec.base64.fromBits(pub.toBits());
	return pubstr.slice(1,88)									//strip initial "A", only x part
};

//key reformatting and stretching for secret Key (shared key is formatted automatically by sjcl) for 521 bit keys
function toexponent(string){
	var iter = keyStrength(string,false);						//get number of iterations from Key strength meter
	var w = sjcl.bitArray;	
	return sjcl.bn.fromBits(w.bitSlice(sjcl.misc.scrypt(string,"",iter,8,1,66)))	//use no salt, iteration number variable according to Key strength, 528 bits
};

//this one makes the shared secret
function makeshared(secstr,xstr){
	var curve = sjcl.ecc.curves["c521"],
		sec = toexponent(secstr),
		ystr = yfromx(curve,'A' + xstr),				      	//retrieve y coordinate from x coordinate. Add the spurious 'A' that SJCL adds to a 521-bit number
		pub = curve.fromBits(sjcl.codec.base64.toBits('A'+xstr+ystr)),  //make public key object containing both x and y
		sharedsec = pub.mult(sec),
		sharedstr = sjcl.codec.base64.fromBits(sharedsec.toBits());
	return sharedstr.slice(2,88)  								//strip spurious initial "A", only x part. Strip also 2nd char so it's not mistaken for a Lock
};

function yfromx(curve,xstr){
	var x = sjcl.bn.fromBits(sjcl.codec.base64.toBits(xstr)),   //the following to retrieve y coordinate from x coordinate
		y = curve.b.add(x.mul(curve.a.add(x.square())));		//this is actually y^2, square root by special case of Tonelli-Shanks follows
	var i;
	for (i=0; i<519; i++) {
  		y = y.square();											//performs y^((p+1)/4), since p = 2^521 - 1, (p+1)/4=2^519, all is mod p
		};
	return sjcl.codec.base64.fromBits(y.toBits());
};

//display a hash of the textarea for authentication purposes
function showhash(){
	var mine = document.getElementById('mainBox').value.trim(),				//remove spaces at start and end
		mainmsg = document.getElementById("mainmsg");
	if (mine.length < 267){										//if it's the length of a signature or shorter remove spaces, tags and anything that is not base64
		mine = striptags(mine)
	}
	if (mine != '') {    										//take hash, make it hex, cut into 4-char pieces and join with dashes
		var newID = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(mine)).match(/.{1,4}/g).join("-");
		mainmsg.innerHTML = 'ID: ' + newID;		
	} else { mainmsg.innerHTML = ''}
};

//this strips initial and final tags, plus spaces and non-base64 characters in the middle
function striptags(string){
	string = string.replace(/\s/g,'');															//remove spaces
	string = string.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags								
	string = string.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 											//takes out anything that is not base64
	return string
}

var encrypting;		//global flag so decoy input doesn't get confused

//AES encryption process: determines the kind of encryption by looking at the radio buttons and check boxes under the main box and the length of the presumed Lock
//This function handles short mode encryption only (no List). Otherwise, Encrypt_for_List() is called
function Encrypt_text(){
	var shortOn = document.getElementById("shortmode").checked,
		learnOn = document.getElementById("learnmode").checked,
		tagsOff = document.getElementById("notags").checked,
		signedOn = document.getElementById("signedmode").checked,
		pfsOn = document.getElementById("pfsmode").checked,
		anonOn = document.getElementById("anonmode").checked,
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg"),
		name = lockmsg.innerHTML,
		clipped = false,
		secstr = document.getElementById('lockBox').value.trim();
	var	pubstr = striptags(secstr);
	if (secstr === ""){
		main2lock();
		lockmsg.innerHTML = '<span style="color:red">Enter a Lock, shared Key, or List</span>';
		throw("lock box empty");
	}
	var listArray = secstr.split('\n');

	if(!shortOn){								//this function handles only short mode, otherwise Encrypt_for_List() is called instead
		Encrypt_for_List(listArray);
		return
	}
	if (listArray.length > 1 && listArray[1].slice(0,4) != 'http'){			//this is a List, which is not compatible with short mode
		mainmsg.innerHTML = '<span style="color:red">Short mode not available for multiple recipients</span>';
		throw('multiple Locks for short mode')
	}
	
	if(pubstr.length != 87){					//key-locked mode, if no Lock is entered
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked with the shared Key in the Locks box, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply3===false) throw("sym encryption canceled");
		};
		var iter = keyStrength(secstr,false);							//get number of iterations from Key strength meter, minimum is 101
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),
			salt = makesalt(iv,37),										//salt can hide 37 chars in short mode
			text = encodeURI(document.getElementById('mainBox').value).replace(/%20/g, ' ');
		if (text.length > 58) clipped = true;	
			text = text + "                                                         ";  //clip or add spaces to make a 58 char message 
			text = text.slice(0,58);
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(secstr,salt,iter,8,1,33));
		var cipherj = JSON.parse(sjcl.encrypt(keyStretched,text,{"iv":iv,"salt":salt,"ks":256,"iter":101}));
		if (learnOn){
			alert(name + " will need to place the same Key in the Locks box to unlock the message in the main box.");
		};
		document.getElementById('mainBox').value = "@" + cipherj.iv + cipherj.salt + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){					//detect mobile
			main2extra();
			mainmsg.innerHTML = 'Locking successful. Copy and click Txt/Img';
			selectMain()
		}
	}
		
	else if (pfsOn){										//PFS mode, similar to Lock mode, but uses permanent storage
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked, in PFS mode, with the item selected in the Locks box, and the result will replace the main box. Cancel if this is not what you want. Cancel if this is not what you want.");
			if(reply3===false) throw("PFS locking canceled");
		};
		var key = readKey();												//secret Key for encrypting dummy Key before storage, check before anything
		if (lockDB[name] == null){											//no name selected
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Select a recipient with a valid Lock by name</span>';
			throw("invalid name")
		}
		var lastLockcipher = lockDB[name][3],								//retrieve dummy Lock from storage, [0] is the permanent Lock by that name
			turnstring = lockDB[name][4];									//this strings says whose turn it is to encrypt
		if (turnstring=='next unlock'){
			var reply4 = confirm("It's not your turn to encrypt a PFS message for " + name + ". If you go ahead, the PFS conversation with this recipient may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS locking canceled");
			}
		if (lastLockcipher != null) {										//if dummy exists, decrypt it first
			var lastLock = keyDecrypt(key,lastLockcipher);
		} else {															//use permanent Lock, minus tags, if dummy doesn't exist
			if (pubstr.length == 87){
				var lastLock = pubstr
			} else {														//if it's a shared Key, use the Lock deriving from it
				var lastLock = makepub(pubstr);
			}
		}
		var newKey = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,86),	//new dummy Key
			newLock = makepub(newKey);	
		var lastKeycipher = lockDB[name][2];							//short mode uses last Key and last Lock. The new lock is sent unencrypted
		if (lastKeycipher != null){	
			var lastKey = keyDecrypt(key,lastKeycipher)
		} else {
			var lastKey = key																	//use permanent Key, if dummy doesn't exist
		}
		var keystr = makeshared(lastKey,lastLock),
			iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),					//11 char serial in short mode, no salt
			salt = "",
			text = encodeURI(document.getElementById('mainBox').value).replace(/%20/g, ' ');
		if (text.length > 37) clipped = true;
			text = text + "                                                         ";   		//clip or add spaces to make a 37 char message 
			text = text.slice(0,37);
		var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
		document.getElementById('mainBox').value = "$" + cipherj.iv + cipherj.salt + newLock + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){											//detect mobile
			main2extra();
			mainmsg.innerHTML = 'Locking successful. To be unlocked by ' + name + ' in PFS mode. Copy and click Txt/Img. Must be first locked after reading.';
			selectMain()
		}							
		lockDB[name][2] = keyEncrypt(key,newKey);							//new Key is stored in the permanent database
		lockDB[name][4] = 'next unlock';
		localStorage.lockDB = JSON.stringify(lockDB);
		
		if(testChromeSync()){												//if Chrome sync is available, change in sync storage
			syncChromeLock(name,JSON.stringify(lockDB[name]))
		}
	}
	
	else if (signedOn){								//signed mode, make encryption key from secret Key and recipient's Lock
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked with your secret secret Key and the Lock in the Locks box, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply3===false) throw("signed encryption canceled");
		};
		var key = readKey();
		if (pubstr.length != 87){
				main2lock();
				lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
				throw("no Lock found");
		}
		
		if (lockDB[name]) var sharedKeycipher = lockDB[name][1];
		if (sharedKeycipher != null){
			var sharedKey = keyDecrypt(key,sharedKeycipher)
		} else {
			var sharedKey = makeshared(key,pubstr);
			if (lockDB[name]){
				lockDB[name][1] = keyEncrypt(key,sharedKey);
				localStorage.lockDB = JSON.stringify(lockDB)
				
				if(testChromeSync()){											//if Chrome sync is available, change in sync storage
					syncChromeLock(name,JSON.stringify(lockDB[name]))
				}
			}
		}
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),
			salt = makesalt(iv,37),														//salt can hide 37 chars in short mode
			text = encodeURI(document.getElementById('mainBox').value).replace(/%20/g, ' ');
		if (text.length > 58) clipped = true;
			text = text + "                                                         ";  //clip or add spaces to make a 58 char message 
			text = text.slice(0,58);
		var cipherj = JSON.parse(sjcl.encrypt(sharedKey,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
		if (learnOn){
			alert(lockmsg + " will need your Lock and his/her secret Key to unlock the message in the main box.");
		};
		document.getElementById('mainBox').value = "#" + cipherj.iv + cipherj.salt + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){									//detect mobile
			main2extra();
			mainmsg.innerHTML = 'Locking successful. Copy and click Txt/Img';
			selectMain()
		}
	}
	
	else if (anonOn){								//anonymous mode, using only the recipient's Lock
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked with the Lock in the Locks box and the result will be placed in the main box. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("public encryption canceled");
		};
		if(name=='') name = "the recipient";
		if (pubstr.length != 87){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
			throw("no Lock found");
		}
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),	//make dummy Key
			pubstrdum = makepub(secstrdum);															//makes 87 char dummy public key, initial A stripped	
		var keystr = makeshared(secstrdum,pubstr);													//make AES key from dummy secret and recipient's public key
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),						//11 char serial in short mode, no salt
			salt = "",
			text = encodeURI(document.getElementById('mainBox').value).replace(/%20/g, ' ');
		if (text.length > 38) clipped = true;
			text = text + "                                                         ";  			//clip or add spaces to make a 38 char message 
			text = text.slice(0,38);			
		var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));   //use 256 bit keys, min stretching for random key
		if (learnOn){
			alert(name + " will need to place his/her secret Key in the key box to unlock the message in the main box.");
		}		
		document.getElementById('mainBox').value = cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct;	//display adding dummy public key and anonymous tags, depending on mode
		if(typeof window.orientation !== 'undefined'){
			main2extra();
			mainmsg.innerHTML = 'Locking successful. Copy and click Txt/Img';
			selectMain();
			
//this bit for phonegap only
			if(window.plugins){
				window.plugins.copy(document.getElementById('mainBox').value)
				mainmsg.innerHTML = 'Locked and copied to clipboard. Click Txt/Img to send'
			}
//end of phonegap bit	

		}		
	}
	if (clipped) mainmsg.innerHTML = "<span style='color:orange'>The message has been truncated</span>"	
	document.getElementById('decoyText').value = "";
	document.getElementById('decoyPwdIn').value = "";
	document.getElementById('decoyPwdOut').value = "";
};

//encrypts for a list of recipients. First makes a 256-bit message key, then gets the Lock or shared Key for each recipient and encrypts the message key with it
//the output string contains each encrypted key along with 66 bits of an encrypted form of the recipient's item, so he/she can find the right encrypted key 
function Encrypt_for_List(listArray){
	var shortOn = document.getElementById("shortmode").checked,
		learnOn = document.getElementById("learnmode").checked,
		tagsOff = document.getElementById("notags").checked,
		signedOn = document.getElementById("signedmode").checked,
		pfsOn = document.getElementById("pfsmode").checked,
		anonOn = document.getElementById("anonmode").checked,
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	if(shortOn){
		mainmsg.innerHTML = '<span style="color:red">Short mode not available for multiple recipients</span>'
		throw('short mode not available')
	}
	
	var warningList = "";
	for (var index = 0; index < listArray.length; index++){										//scan lines and pop a warning if some are not on DB or aren't Locks
		var name = listArray[index].trim();
		if (name.slice(0,4)=='http') {
			listArray[index] = '';
			name = ''
		}
		if (name != ''){
			if(lockDB[name] == null) {					//not on database; see if it's a Lock, and otherwise add to warning list
				var namestr = striptags(name);
				if(namestr.length!=87){
					if (warningList==""){warningList = name} else {warningList = warningList + '\n' + name}
				}
			}
		}
	}
	if (warningList!=''){
		var agree = confirm('The names on the list below were not found in your local directory. If you go ahead, they will be used as shared Keys for locking and unlocking the message. This could be a serious security hazard:\n\n' + warningList);
		if (!agree) throw('list encryption terminated by user')
	}
	
	var	msgkey = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')).slice(0,43),		//message key a little over 256-bit
		iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('4','0')),
		text = document.getElementById('mainBox').value;
	if (anonOn) {
		if (learnOn){
			var reply = confirm("The contents of the main box will be anonymously locked with the Locks of the recipients listed in the Locks box, so that all of them can read it with their respective Keys, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list encryption canceled");
		}
		var salt = makesalt(iv,87);											//salt hides 87 chars in anonymous, 152 otherwise. Tags are different, too
		if(tagsOff){														//initial tag
			var outString = "!"
		} else {
			var outString = "PL17msa=!"
		}
	} else if(pfsOn){
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked in PFS mode with the Locks of the recipients listed in the Locks box, so that all of them can read it with their respective Keys, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list encryption canceled");
		}
		var salt = makesalt(iv,87);
		if(tagsOff){
			var outString = "$"
		} else {
			var outString = "PL17msp=$"
		}				
	} else {
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked with the Locks of the recipients listed in the Locks box and signed with your Key, so that all of them can read it by supplying your Lock, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("signed list encryption canceled");
		}
		var salt = makesalt(iv,152);
		if(tagsOff){
			var outString = "#"
		} else {
			var outString = "PL17mss=#"
		}
	}
	var cipherj = JSON.parse(sjcl.encrypt(msgkey,text,{"iv":iv,"salt":salt,"ks":256,"iter":101}));		 //main encryption event, but don't add it yet 
	outString = outString + cipherj.iv + cipherj.salt;
	
	if (anonOn) {															//for anonymous mode, make dummy Lock and add it to the output string
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),
			pubstrdum = makepub(secstrdum);	
		outString = outString + pubstrdum
	}
	
	//for each item on the List (unless empty), encrypt the message key and add it, prefaced by the first 256 bits of the ciphertext when the item is encrypted with message iv and salt, and the shared key
	for (var index = 0; index < listArray.length; index++){
		var name = listArray[index].trim();
		if (name != ''){
			if(lockDB[name] != null) {										//get item from the lockDB database and decrypt it before using it
				if (key == null) var key = readKey();
				var string = lockDB[name][0],
					secstr = keyDecrypt(key,string.slice(1,string.length));
			} else var secstr = name;										//allow for adding items directly to the List, now strip tags to see if it's a Lock				
			var pubstr = striptags(secstr);		
			if (pubstr.length == 87){										//if it's a Lock, do anonymous, PFS or signed encryption, and add the result to the output			
				if (signedOn){
					if (key == null) var key = readKey();
					if(lockDB[name]!=null){
						var sharedKeycipher = lockDB[name][1];					//permanent key shared with recipient, for encrypting the new dummy Lock
						if (sharedKeycipher != null){
							var sharedKey = keyDecrypt(key,sharedKeycipher);
						} else {
							var sharedKey = makeshared(key,pubstr);
							lockDB[name][1] = keyEncrypt(key,dualKey);		
						}
					} else {
						var sharedKey = makeshared(key,pubstr)
					}
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(sharedKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));			
				} else if (anonOn){
					var sharedKey = makeshared(secstrdum,pubstr);
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(sharedKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
				} else if (pfsOn){
					if(lockDB[name] == null){
						if(lockDB[lockmsg.innerHTML] != null && listArray.length == 1){
							name = lockmsg.innerHTML
						} else {
							mainmsg.innerHTML = 'In PFS mode, recipient Locks must be stored and their names displayed';
							throw('name not on lockDB')
						}
					}
					if (key == null) var key = readKey();					
					var dualKeycipher = lockDB[name][1],
						turnstring = lockDB[name][4];
					if (turnstring=='next unlock'){
						var reply4 = confirm("It's not your turn to encrypt a PFS message for " + name + ". If you go ahead, the PFS conversation with this recipient may become corrupted. Cancel if this is not what you want.");
						if(reply4===false) throw("PFS locking canceled");
					}
					if (dualKeycipher != null){
						var dualKey = keyDecrypt(key,dualKeycipher);
					} else {					
						var dualKey = makeshared(key,pubstr)
						lockDB[name][1] = keyEncrypt(key,dualKey);		
					}					
					
					var lastLockcipher = lockDB[name][3];						//retrieve dummy Lock from storage, [0] is the permanent Lock by that name
					if (lastLockcipher != null) {								//if dummy exists, decrypt it first
						var lastLock = keyDecrypt(key,lastLockcipher);
					} else {													//use permanent Lock, minus tags, if dummy doesn't exist
						var lastLock = pubstr				
					}
					
					var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),		//different dummy key for each recipient
						pubstrdum = makepub(secstrdum);					
					var sharedKey = makeshared(secstrdum,lastLock);
					lockDB[name][2] = keyEncrypt(key,secstrdum);				//new Key is stored in the permanent database
					lockDB[name][4] = 'next unlock';
					localStorage.lockDB = JSON.stringify(lockDB);
					
					if(testChromeSync()){										//if Chrome sync is available, change in sync storage
						syncChromeLock(name,JSON.stringify(lockDB[name]))
					}

				//sharedKey depends on the newLock, so use the permanent shared Key instead for making the idtag and encrypting the newLock
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(dualKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						newLockcipher = JSON.parse(sjcl.encrypt(dualKey,pubstrdum,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
				}
			} else {														//if it's not a Lock, do a symmetric encryption instead, with appropriate key stretching
				var iter = keyStrength(secstr,false),
					keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(secstr,salt,iter,8,1,33)),
					cipherj2 = JSON.parse(sjcl.encrypt(keyStretched,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter":101})),
					idtag = JSON.parse(sjcl.encrypt(secstr,secstr,{"iv":iv,"salt":salt,"ks":256,"iter":101}));
			}
			if (pfsOn && pubstr.length == 87){
				outString = outString + '%' + idtag.ct.slice(0,11) + '%' + newLockcipher.ct + cipherj2.ct;
			} else {
				outString = outString + '%' + idtag.ct.slice(0,11) + '%' + cipherj2.ct;
			}
		}
	}
	
	//finish off by adding the encrypted message and tags
	outString = outString + '%' + cipherj.ct
	if (tagsOff) {
			document.getElementById('mainBox').value = outString
	} else {
		if(anonOn){
			document.getElementById('mainBox').value = outString + "=PL17msa"
		} else if(pfsOn){
			document.getElementById('mainBox').value = outString + "=PL17msp"
		} else {
			document.getElementById('mainBox').value = outString + "=PL17mss"
		}
	}
	mainmsg.innerHTML = 'Locking successful'
}

//reads key box and stops if there's something wrong or the timer has run out
function readKey(){
	clearTimeout(keytimer);																			//reset key timer
	keytimer = setTimeout(function() {document.getElementById('pwd').value = ''}, 300000);
	
	var key = document.getElementById('pwd').value.trim();
	if (key == ""){
		any2key();
		document.getElementById("keymsg").innerHTML = 'Please enter your secret Key and retry.';
		throw ('secret Key needed to encrypt item')
	}
	return key
}

//decrypts a string encrypted with the secret Key, 11 char serial, no salt, variable key stretching
function keyDecrypt(key,cipherstring){
	var	iv = cipherstring.slice(0,11),
		ct = cipherstring.slice(11,cipherstring.length),
		iter = keyStrength(key,false);
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
	var cipherstr2 = '{"iv":"' + iv + '","salt":"' + '' + '","ct":"' + ct + '","ks":256,"iter":101}';
	return sjcl.decrypt(keyStretched,cipherstr2)	
}

//encrypts a string with the secret Key, 11 char serial, no salt, variable key stretching
function keyEncrypt(key,plainstring){
	var	iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),				//minimum iterations = 101
		iter = keyStrength(key,false);
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
	var cipherj2 = JSON.parse(sjcl.encrypt(keyStretched,plainstring,{"iv":iv,"salt":"","ks":256,"iter":101}));	
	return cipherj2.iv + cipherj2.ct
}

//encrypts a hidden message into the salt value used by regular encryption, or makes a random salt also encoded by AES so it's indistinguishable
function makesalt(iv,leng){
	if (document.getElementById("decoymode").checked === true){
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("You are adding a hidden message in Decoy mode. Cancel if this is not what you want, then uncheck Decoy mode below.");
			if(reply===false) throw("decoy encryption canceled");
		};
		if ((document.getElementById('decoyPwdIn').value.trim() == "")||(document.getElementById('decoyText').value.trim() == "")){ //stop to display the decoy entry form if there is no hidden message or key
			document.getElementById("decoyIn").style.display = "block";					//display decoy form, and back shadow
			document.getElementById("shadow").style.display = "block";	
			throw ("stopped for decoy input")				
		}
		var key = document.getElementById('decoyPwdIn').value,
			text = encodeURI(document.getElementById('decoyText').value.replace(/%20/g, ' ')),
			iter = keyStrength(key,false);												//key may be weak, so stretch it
	} else {																			//no decoy mode, so salt comes from random text and key, no extra stretching
		var key = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')),
			text = sjcl.codec.base64.fromBits(sjcl.random.randomWords('57','0')).slice(0,214),
			iter = 2;
	};
	while (text.length < leng) {														//clip or add spaces to make the number of characters required
			text = text + "          ";
		};
		text = text.slice(0,leng);
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
		var cipherj = JSON.parse(sjcl.encrypt(keyStretched,text,{"iv":iv,"salt":"","ks":256,"iter":101}));
		return cipherj.ct;
};

//AES decryption process: determines which kind of encryption by looking at first character after the initial tag. Calls Encrypt_text as appropriate
function Decrypt_text(){
	encrypting = true;
	var decoyOn = document.getElementById("decoymode").checked,
		learnOn = document.getElementById("learnmode").checked,
		keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	keymsg.innerHTML = "";
	mainmsg.innerHTML = "";
	var name = lockmsg.innerHTML,
		cipherstr = document.getElementById('mainBox').value.trim(),
		secstr = document.getElementById('lockBox').value.trim();
	if (cipherstr===""){																//if the main box is empty, display a warning
		mainmsg.innerHTML = '<span style="color:red">Nothing to lock or unlock</span>';
		throw("main box empty");
	};
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags
		
	//here detect if the message is for multiple recipients, and if so call the appropriate program
	var cipherArray = cipherstr.split('%');
	if(cipherArray.length > 3){
		if (cipherArray[1].length == 11){
			Decrypt_from_List(cipherArray);
			return
		}
	}
	var pubstr = striptags(secstr);
	var type = cipherstr.slice(0,1);													//get encryption type. !=public, @=symmetric, #=signed
		cipherstr = cipherstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');							//remove anything that is not base64
	
	if (cipherstr.length==160){					//short asymmetric decryption
		if (learnOn){
			var reply = confirm("The short message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key has been entered, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		var key = readKey();
		var	iv = cipherstr.slice(0,11),													//get iv, salt, and later ct data and public key
			salt = "";			
		var pubstrdum = cipherstr.slice(11,98);
		var keystr = makeshared(key,pubstrdum);
		var	ct = cipherstr.slice(98,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.getElementById('mainBox').value = sjcl.decrypt(keystr,cipherstr).trim();
		if(!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
	}
	
	else if (type == "~"){																//secret Key encrypted item, such as a complete lockDB database
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your secret Key, and will now be unlocked if your secret Key has been entered, and placed in the Locks screen so you can merge it into the stored database. Cancel if this is not what you want.");
			if(reply===false) throw("secret Key decryption canceled");
		};
		var key = readKey();
		document.getElementById('lockBox').value = keyDecrypt(key,cipherstr);
		document.getElementById("lockmsg").innerHTML = 'Decrypted items. Click Merge or Save to add them to this device.';
		main2lock();
	}
	
	else if (type === "!"){							//regular asymmetric decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key has been entered, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		var key = readKey();
		var	iv = cipherstr.slice(0,22),													//get iv, salt, and later ct data and public key
			salt = cipherstr.slice(22,149);			
		if (decoyOn) decoydecrypt(iv,salt); 											//do decoy decryption first, in case regular fails
		var pubstrdum = cipherstr.slice(149,236);
		var keystr = makeshared(key,pubstrdum),
			ct = cipherstr.slice(236,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.getElementById('mainBox').value = sjcl.decrypt(keystr,cipherstr);
		if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
	}	
	
	else if (type == "$"){							//PFS decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked in PFS mode with your personal Lock and will now be unlocked, replacing the locked message, if your secret Key has been entered. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		if (lockDB[name] == null){														//no name selected
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Select a sender with a valid Lock</span>';
			throw("invalid name")
		}
		var key = readKey();
		var lastKeycipher = lockDB[name][2],											//retrieve dummy Key from storage, [0] is the permanent Lock by that name
			turnstring = lockDB[name][4];												//this strings says whose turn it is to encrypt
		if (turnstring=='next lock'){
			var reply4 = confirm("It's not your turn to decrypt a PFS message from " + name + ". If you go ahead, the PFS conversation with this sender may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS unlocking canceled");
		}
		if (lastKeycipher != null) {
			var lastKey = keyDecrypt(key,lastKeycipher)	
		} else {																		//if it doesn't exist, use permanent Key, or shared Key if no Lock
			if (pubstr.length == 87){
				lastKey = key
			} else {
				lastKey = pubstr
			}			
		}			
		var lastLockcipher = lockDB[name][3];										//short mode uses last Key and last Lock
		if (lastLockcipher != null) {												//if dummy exists, decrypt it first
			var lastLock = keyDecrypt(key,lastLockcipher)
		} else {																	//use permanent Lock, minus tags, if dummy doesn't exist
			if (pubstr.length != 87){
				main2lock();
				lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
				throw("no Lock found");
			}
			var lastLock = pubstr;
		}
		var	iv = cipherstr.slice(0,11),
			salt = "",
			newLock = cipherstr.slice(11,98),
			ct = cipherstr.slice(98,cipherstr.length),			
			keystr = makeshared(lastKey,lastLock),
			cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		document.getElementById('mainBox').value = sjcl.decrypt(keystr,cipherstr2).trim();
		if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful. You can read this only once.'
		lockDB[name][3] = keyEncrypt(key,newLock);
		lockDB[name][4] = 'next lock';
		localStorage.lockDB = JSON.stringify(lockDB);
		
		if(testChromeSync()){											//if Chrome sync is available, change in sync storage
			syncChromeLock(name,JSON.stringify(lockDB[name]))
		}
	}	
	
	else if (type === "#"){							//signed decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your Lock and the sender's Key, and will now be unlocked, replacing the locked message, if your secret Key has been entered. Cancel if this is not what you want.");
			if(reply===false) throw("signed decryption canceled");
		};
		if (pubstr == ''){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>Enter the sender's Lock</span>";
			throw("lock box empty");
		}
		var key = readKey();
		if (lockDB[name]) var sharedKeycipher = lockDB[name][1];
		if (sharedKeycipher != null){
			var sharedKey = keyDecrypt(key,sharedKeycipher)
		} else {
			var sharedKey = makeshared(key,pubstr)
			if (lockDB[name]) {
				lockDB[name][1] = keyEncrypt(key,sharedKey);
				localStorage.lockDB = JSON.stringify(lockDB);
				
				if(testChromeSync()){											//if Chrome sync is available, change in sync storage
					syncChromeLock(name,JSON.stringify(lockDB[name]))
				}
			}
		}
		var	iv = cipherstr.slice(0,11),
			salt = cipherstr.slice(11,71),
			ct = cipherstr.slice(71,cipherstr.length);
		if (decoyOn) decoydecrypt(iv,salt);
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		if (cipherstr.length == 159){
			document.getElementById('mainBox').value = sjcl.decrypt(sharedKey,cipherstr2).trim();
			if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
		}else{
			document.getElementById('mainBox').value = sjcl.decrypt(sharedKey,cipherstr2);
			if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
		}
	}
	
	else if (type === "@"){							//symmetric decryption
		if (learnOn){
			var reply2 = confirm("The message in the main box was locked with a shared Key, and will now be unlocked if the same Key is present in the Locks box. The result will replace the locked message. Cancel if this is not what you want.");
			if(reply2===false) throw("sym decryption canceled");
		};
		if (secstr == ''){
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Enter shared Key</span>';
			throw("symmetric key empty");
		}
		var	iv = cipherstr.slice(0,11),
			salt = cipherstr.slice(11,71),
			ct = cipherstr.slice(71,cipherstr.length);			
		var keystr = secstr;
		if (decoyOn) decoydecrypt(iv,salt);
		var iter = keyStrength(keystr,false);											//get number of iterations from Key strength meter
		var keyStretched=sjcl.codec.base64.fromBits(sjcl.misc.scrypt(keystr,salt,iter,8,1,33));
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		if (cipherstr.length == 159){
			document.getElementById('mainBox').value = sjcl.decrypt(keyStretched,cipherstr2).trim();
			if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
		}else{
			document.getElementById('mainBox').value = sjcl.decrypt(keyStretched,cipherstr2);
			if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'
		}	
	}else{
		Encrypt_text()								//none of the known encrypted types, therefore encrypt rather than decrypt
	};
};

//decrypts a message encrypted for multiple recipients. Encryption can be signed, anonymous, or symmetric
function Decrypt_from_List(cipherArray){
	encrypting = true;
	var decoyOn = document.getElementById("decoymode").checked,
		learnOn = document.getElementById("learnmode").checked,
		keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	keymsg.innerHTML = "";
	mainmsg.innerHTML = "";
	var name = lockmsg.innerHTML,
		type = cipherArray[0].slice(0,1);
	for (var i=0; i < cipherArray.length; i++){
		cipherArray[i] = cipherArray[i].replace(/[^a-zA-Z0-9+/ ]+/g, '')				//take out anything that is not base64
	}
	var iv = cipherArray[0].slice(0,22);
	if (type == '!' || type == '$') {
		var salt = cipherArray[0].slice(22,149),
			pubstrdum = cipherArray[0].slice(149,236)	
	} else {
		var salt = cipherArray[0].slice(22,236)
	}
	if (decoyOn) decoydecrypt(iv,salt);													//decoy decryption
	var ct = cipherArray[cipherArray.length - 1],
		secstr = document.getElementById('lockBox').value.trim(),
		pubstr = striptags(secstr);
		
	if(lockDB['myself'] == null) key2any();												//make this entry if it has been deleted
		
	//now make the idtag to be searched for, depending on the type of encryption. First the shared Key that encrypts the idtag
	
	if (type == '#' || type == '$'){				//signed mode first, PFS is the same at this point
		if (learnOn){
			var reply = confirm("The contents of the message in the main box will be unlocked with your secret Key, provided you have placed the sender's Lock or shared Key in the Locks box. Cancel if this is not what you want.");
			if(reply===false) throw("signed list decryption canceled");
		}
		if (pubstr == ''){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>Enter the sender's Lock or shared Key</span>";
			throw("lock box empty");
		}
		if (pubstr.length == 87){														//assuming this is a Lock, not a shared Key. See below for the other case
			var key = readKey();
			if (lockDB[name]) var sharedKeycipher = lockDB[name][1];					//get permanent shared Key from storage, or make it if not stored
			if (sharedKeycipher != null){
				var sharedKey = keyDecrypt(key,sharedKeycipher)
			} else {
				var sharedKey = makeshared(key,pubstr)
				if (lockDB[name]) {
					lockDB[name][1] = keyEncrypt(key,sharedKey);
					localStorage.lockDB = JSON.stringify(lockDB);
					
					if(testChromeSync()){												//if Chrome sync is available, change in sync storage
						syncChromeLock(name,JSON.stringify(lockDB[name]))
					}
				}	
			}
			var string = lockDB['myself'][0];
			secstr = keyDecrypt(key,string.slice(1,string.length))						//this contains my Lock
		} else {																		//assuming it's a regular shared Key in common with the sender
			var sharedKey = secstr
		}
		
	} else {										//anonymous mode
		if (learnOn){
			var reply = confirm("The contents of the message in the main box will be unlocked with your secret Key. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list decryption canceled");
		}
		if (pubstr.length == 87 || pubstr == ''){
			if (key == null) var key = readKey();
			var sharedKey = makeshared(key,pubstrdum),
				string = lockDB['myself'][0];
			secstr = keyDecrypt(key,string.slice(1,string.length))
		} else {
			var sharedKey = secstr
		}
	}
	var iter = keyStrength(sharedKey,false);										//should be 2 for everything except bad shared Keys
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(sharedKey,salt,iter,8,1,33));
	var	idtag = JSON.parse(sjcl.encrypt(sharedKey,secstr,{"iv":iv,"salt":salt,"ks":256,"iter":101})).ct.slice(0,11);
				
	//look for the id tag and return the string that follows it
	for (i = 1; i < cipherArray.length; i++){
		if (idtag == cipherArray[i]) {
			var msgkeycipher = cipherArray[i+1];
		}
	}
	
	//got the encrypted message key, now decrypt it, and finally the main message. The process for PFS mode is more involved
	if ((pubstr.length != 87) && (pubstr.length != 0)){
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(sharedKey,salt,iter,8,1,33))
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(keyStretched,cipherstr2).trim();
	} else if (type != '$'){
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(sharedKey,cipherstr2).trim();
			
	//for PFS mode, first we separate the encrypted new Lock from the proper message key, then decrypt the new Lock and combine it with the stored Key (if any) to get the ephemeral shared Key, which unlocks the message Key
	} else {
		var newLockcipher = msgkeycipher.slice(0,127);
		msgkeycipher = msgkeycipher.slice(127,msgkeycipher.length);
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + newLockcipher + '","ks":256,"iter":101}',
			newLock = sjcl.decrypt(sharedKey,cipherstr2).trim();
		var lastKeycipher = lockDB[name][2],											//retrieve dummy Key from storage
			turnstring = lockDB[name][4];												//this strings says whose turn it is to encrypt
		if (turnstring=='next lock'){
			var reply4 = confirm("It's not your turn to decrypt a PFS message from " + name + ". If you go ahead, the PFS conversation with this sender may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS unlocking canceled");
		}
		if (lastKeycipher != null) {
			var lastKey = keyDecrypt(key,lastKeycipher)
		} else {																		//if a dummy Key doesn't exist, use permanent Key
			var lastKey = key
		}
		var	keystr = makeshared(lastKey,newLock),
			cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(keystr,cipherstr2).trim();
		lockDB[name][3] = keyEncrypt(key,newLock);										//store the new dummy Lock
		lockDB[name][4] = 'next lock';
		localStorage.lockDB = JSON.stringify(lockDB);
		
		if(testChromeSync()){															//if Chrome sync is available, change in sync storage
			syncChromeLock(name,JSON.stringify(lockDB[name]))
		}
	}	
	var cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
	document.getElementById('mainBox').value = sjcl.decrypt(msgkey,cipherstr);
	if (!decoyOn) mainmsg.innerHTML = 'Unlocking successful'	
}

//decrypt the message hidden in the salt, for decoy mode
function decoydecrypt(iv,ct){
	var mainmsg = document.getElementById("mainmsg");
	mainmsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var	key2 = prompt("Decoy mode is selected, so please write the Password used to lock the hidden message. If you don't expect a hidden message, uncheck Decoy mode below.");
	} else {
	if (document.getElementById('decoyPwdOut').value.trim() == ""){										//stop to display the decoy key entry form if there is no key entered
		document.getElementById("decoyOut").style.display = "block";
		document.getElementById("shadow").style.display = "block";			
		throw ("stopped for decoy input")				
	}	
	var key2 = document.getElementById('decoyPwdOut').value,
		iter = keyStrength(key2,false);
	document.getElementById('decoyPwdOut').value = ""
	};
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key2,'',iter,8,1,33))
	var	cipherstr2 = '{"iv":"' + iv + '","salt":"' + "" + '","ct":"' + ct + '","ks":256,"iter":101}';
	mainmsg.innerHTML = 'Hidden message: <span style="color:blue">' + decodeURI(sjcl.decrypt(keyStretched,cipherstr2)) + '</span>'
};

//takes a SHA512 hash of the plaintext and generates an ECDSA signature
function Signhash(){
	var keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var secstr = readKey();
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A signature matching the contents of the main box will be made using your secret Key, and the resulting signature will be added to the end of the main box. Cancel if this is not what you want.");
		if(reply===false) throw("signature canceled");
	};
	var pubstr = striptags(secstr);
	if (pubstr.length===87){															//this is a Lock, not a Key
		any2key();
		keymsg.innerHTML = '<span style="color:red">This is a Lock. Enter your Key here</span>';	
		throw("lock instead of key")
	};
	var hash = sjcl.hash.sha512.hash(document.getElementById('mainBox').value.trim()),					//take SHA512 hash of plaintext, trimming space at ends
		sec = toexponent(secstr),
		curve = sjcl.ecc.curves["c521"],
		R = curve.r,
		l = R.bitLength(),
    	k = sjcl.bn.random(R.sub(1), 0).add(1),
    	r = curve.G.mult(k).x.mod(R),
		s = sjcl.bn.fromBits(hash).add(r.mul(sec)).mul(k.inverseMod(R)).mod(R),
		sigstr = sjcl.codec.base64.fromBits(sjcl.bitArray.concat(r.toBits(l), s.toBits(l)));	//make it base64
	var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),				//for hidden message, if activated
		padding = makesalt(iv,40);
	if (document.getElementById("notags").checked === false){
			//strip initial "A" and add decoy iv & padding and tags
		document.getElementById('mainBox').value = document.getElementById('mainBox').value + "\n\n" + "PL17sig=" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding + "=PL17sig";
	}else{
		document.getElementById('mainBox').value = document.getElementById('mainBox').value + "\n\n" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding
	}
};	

//verifies the ECDSA signature of a hash of the plaintext, calls Signhash as appropriate. Algorithm from SJCL ecc.js, but not the latest version
function Verifyhash(){
	encrypting = false;
	var keymsg = document.getElementById("keymsg"),
		lockmsg = document.getElementById("lockmsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var text = document.getElementById('mainBox').value.trim();
	if (text==""){																		//nothing in text box
		mainmsg.innerHTML = '<span style="color:red">Nothing to sign or verify</span>';
		throw("no text")
	};
	var	sign = text.split(/\r?\n/);
		sign = sign[sign.length-1];														//this is a signature if added as last line of text
	var sigstr = striptags(sign);
	if (!(sigstr.length == 250)){													//no signature tag, therefore making sign	
		Signhash();
		throw("no signature, creating one")
	};
	var	pubstr = document.getElementById('lockBox').value.trim();
	if (pubstr==""){
		main2lock();
		lockmsg.innerHTML = '<span style="color:red">Enter a Lock to verify the signature</span>';	
		throw("no lock present")
	};
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in the main box has been signed with somebody's secret Key. I will now verify if the sign is correct for this text and the matching Lock, which should be present in the Locks box, and will display the result in a popup. Cancel if this is not what you want.");
		if(reply===false) throw("sign verification canceled");
	};
		pubstr = striptags(pubstr);
	if (!(pubstr.length == 87)){
		lockmsg.innerHTML = '<span style="color:red">Enter a valid Lock and try again</span>';
		throw("invalid public key")
	};
		text = text.replace(/\r?\n?[^\r\n]*$/, "");										//remove last line
	var hash = sjcl.hash.sha512.hash(text.trim()),										//take SHA512 hash of plaintext, ignoring initial and end spaces			
		curve = sjcl.ecc.curves["c521"],
		xstr = "A" + pubstr.slice(0,pubstr.length),
		ystr = yfromx(curve,xstr),
	 	pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),
		rs = sjcl.codec.base64.toBits("A" + sigstr.slice(0,175)),						//recover signature part
		w = sjcl.bitArray,
        R = curve.r,
        l = R.bitLength(),
        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),
        s = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),
		u = s.inverseMod(R),	
        hG = sjcl.bn.fromBits(hash).mul(u).mod(R),	
        hA = r.mul(u).mod(R),
		check = true,	
		r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		if (!r2.equals(r)){																//hack from when y is the wrong root of y^2
			var y = sjcl.bn.fromBits(sjcl.codec.base64.toBits(ystr)),
				p = curve.field.modulus.copy(),
				y2 = p.sub(y),															//this should be the right y
				ystr2 = sjcl.codec.base64.fromBits(y2.toBits());		
			pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr2));
			r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		};																				//end of wrong root hack
    if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) check = false;
	if (check) {
		mainmsg.innerHTML = '<span style="color:green">The signature is VERIFIED</span>'
		}
	else {
		mainmsg.innerHTML = '<span style="color:magenta">The signature has FAILED verification</span>'
		};
	if (document.getElementById("decoymode").checked === true){							//this part to extract the hidden message, if it exists
		var iv = sigstr.slice(175,186),
			padding = sigstr.slice(186,250);
		decoydecrypt(iv, padding);
	};
};


//displays how many characters are left, in Short mode
function charsLeft(){
	var mainmsg = document.getElementById("mainmsg");
	if(document.getElementById("shortmode").checked){									//don't do anything unless it's short mode
		var chars = encodeURI(document.getElementById('mainBox').value).replace(/%20/g, ' ').length;
		var pubstr = striptags(document.getElementById('lockBox').value);	
		if(pubstr.length != 87){														//symmetric mode, 58 chars
			var limit = 58
		} else if(document.getElementById("anonmode").checked){							//anonymous mode, 38 chars
			var limit = 38
		} else if(document.getElementById("signedmode").checked){						//signed mode, 58 chars
			var limit = 58
		} else if(document.getElementById("pfsmode").checked){							//pfs mode, 37 chars
			var limit = 37
		}
		if (chars <= limit){
			mainmsg.innerHTML = chars + " characters out of " + limit + " used"
		} else {
			mainmsg.innerHTML = '<span style="color:orange">Maximum length exceeded. The message will be truncated</span>'
		}
	} else {
		showhash()
	}
}

//formats results depending on tags present and sends to default email
function sendMail() {
	var	mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A new tab will open, including the contents of this box in your default email. You still need to supply the recipient's address and a title. Only Locks and locked or signed text are allowed. Cancel if this is not what you want.");
		if(reply===false) throw("email canceled");
	};
	var cipherstr = document.getElementById('mainBox').value;
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
	var type = cipherstr.slice(0,1);
if (document.getElementById("notags").checked === false){							//add tags if checked, add explanatory text	
	if(type==="!"){
    	var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) + "%0D%0A%0D%0AGet PassLok at https://passlok.com";
	} else if (type==="@"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with shared Key. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) + "%0D%0A%0D%0AGet PassLok at https://passlok.com";
	} else if (type==="#"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) + "%0D%0A%0D%0AGet PassLok at https://passlok.com";
	} else if (type==="$"){
		var link = "mailto:"+ "?subject=" + "&body=PFS message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) + "%0D%0A%0D%0AGet PassLok at https://passlok.com";
	} else if (type==="~"){
		var link = "mailto:"+ "?subject=My PassLok database" + "&body=Database locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with my secret Key. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value);	
	} else if (cipherstr.length===87){
		var link = "mailto:"+ "?subject=" + "&body=This is my PassLok v.1.7 Lock, use it to send me messages and verify my signature. %0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) +"%0D%0A%0D%0AGet PassLok at https://passlok.com";		
	} else if (cipherstr.length===160){
		var link = "mailto:"+ "?subject=" + "&body=Short message locked with PassLok v.1.7 %0D%0A%0D%0AStrip everything but the locked message and unlock normally.%0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value) + "%0D%0A%0D%0AGet PassLok at https://passlok.com";
	} else if (cipherstr.length===250){
		var link = "mailto:"+ "?subject=" + "&body=The following is a text signed with PassLok v.1.7. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at https://passlok.com%0D%0A%0D%0AThe text, followed by the signature,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value);
			
	} else {																		//may be a longish signed text, so try a little harder
		var cipherstrArray = document.getElementById('mainBox').value.split('\n'),
			length = cipherstrArray.length,
			cipherstr = cipherstrArray[length-1];
		cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
		if (cipherstr.length==250){
			var link = "mailto:"+ "?subject=" + "&body=The following is a text signed with PassLok v.1.7. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at https://passlok.com%0D%0A%0D%0AThe text, followed by the signature,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.getElementById('mainBox').value);			
		} else {
			mainmsg.innerHTML = 'Only Locks, and locked or signed text are allowed for Email';
			throw("illegal text")
		}
	}
}else{																				//tags unchecked, no extra text
	if((type=="!")||(type=="@")||(type=="#")||(type=="$")||(cipherstr.length==87)||(cipherstr.length==250)||(cipherstr.length==160)){
		var link = "mailto:"+ "?subject=" + "&body=" + encodeURIComponent(document.getElementById('mainBox').value);
	}else{
		mainmsg.innerHTML = '<span style="color:red">Only Locks, and locked or signed text are allowed for Email</span>';		
		throw("illegal text")
	}
}
	if(typeof window.orientation !== 'undefined'){ 	 								//new window for PC, same window for mobile
		window.open(link,"_parent")
	} else {
		window.open(link,"_blank")
	}
}

//calls texting app (works on mobile only), or the image hiding functions (non-mobile)
function sendSMS() {
	if(typeof window.orientation != 'undefined'){
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The default texting app will now open. You need to have copied your short locked message to the clipboard before doing this, if you want to send one. This only works in smartphones. Cancel if this is not what you want.");
			if(reply===false) throw("SMS canceled");
		};
		
//this bit for phonegap only
		if(window.plugins){
			window.plugins.copy(document.getElementById('mainBox').value)
		}
//end of phonegap bit		
	
		window.open("SMS:","_parent")							//open SMS on mobile
	} else {																		//open image screen non-mobile
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("A new screen will open so you can load an image and hide the contents of the box in it. This only works for valid PassLok output. Cancel if this is not what you want.");
			if(reply===false) throw("Image canceled");
		};
		openClose('mainscr');
		openClose('imagescr');
		if(document.getElementById('preview').src.slice(0,4)!='data'){document.getElementById('imagemsg').innerHTML='Click the button above to load an image'}
	}
};

//this function implements the Shamir Secret Sharing Scheme, taking the secret from the main box and putting the result back there, and vice-versa.
function secretshare(){
	var learnOn = document.getElementById("learnmode").checked,
		mainmsg = document.getElementById("mainmsg"),
		main = document.getElementById('mainBox').value.trim();
	if((main.slice(0,8).match(/p\d{3}/) && main.slice(0,2)=='PL') || (main.match(/\n\nA/) && main.slice(0,1)=='A')){		//main box has parts: join parts or make one more part
		var shares = main.replace(/\n\s*\n/g, '\n').split("\n"),					//go from newline-containing string to array
			n = shares.length,
			quorumarr = main.match(/p\d{3}/);															//quorum in tags is "p" plus 3 digits in a row, first instance
		if(quorumarr == null) {var quorum = n} else {var quorum = parseInt(quorumarr[0].slice(1,4))};	//if tags are missing, ignore quorum, otherwise read it form tags
		if(n < quorum){																//not enough parts
			mainmsg.innerHTML = '<span style="color:red">According to the tags, you need ' + (quorum - n) + ' more parts in the box</span>'
		};	
		for (var i=0; i < shares.length; i++) {
			shares[i] = shares[i].split("=").sort(function (a, b) { return b.length - a.length; })[0];	//remove tags
			var isLock = shares[i].length;
			shares[i] = "8" + sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(shares[i].replace(/[^a-zA-Z0-9+/ ]+/g, '')));	//retrieve from base64 back to hex and add initial "8" to each item
		};
		if (learnOn){
			var reply = confirm("The parts in the main box will be joined to retrieve the original item, which will be placed in this box. Please make sure that there are enough parts. Cancel if this is not what you want.");
			if(reply===false) throw("SSSS join canceled");
		};
		if(n === 1){
			mainmsg.innerHTML = '<span style="color:red">Only one part in main box</span>';
			throw("insufficient parts")
		};
		var	sechex = secrets.combine(shares),
			secret = sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(sechex));
		document.getElementById('mainBox').value = secret;
		mainmsg.innerHTML = 'Join successful';
	} else {																		//main box empty: split secret in the box
		if (main == "") {
			mainmsg.innerHTML = '<span style="color:red">The box is empty</span>';
			throw("No key in the key box")
		};
		if (learnOn){
			var reply = confirm("The item in the box will be split into several partial items, which will replace the contents of the box. A popup will ask for the total number of parts, and the minimum needed to reconstruct the original item. Cancel if this is not what you want.");
			if(reply===false) throw("SSSS split canceled");
		};
		var number = document.getElementById('partsNumber').value;
		if (number.trim() == ""){								//stop to display the entry form if it is empty
			document.getElementById("partsIn").style.display = "block";
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for # of parts input")				
		}	
		var quorum = document.getElementById('partsQuorum').value;							//on re-execution, read the box and reset it
		document.getElementById('partsNumber').value = "";
		document.getElementById('partsQuorum').value = "";
		quorum = parseInt(quorum);
		number = parseInt(number);
		if(number < 2){number = 2} else if(number > 255) {number = 255};
		if (quorum > number) quorum = number;
		var	sechex = sjcl.codec.hex.fromBits(sjcl.codec.utf8String.toBits(document.getElementById('mainBox').value)),
			shares = secrets.share(sechex,number,quorum);
		displayshare(shares,quorum);
		mainmsg.innerHTML = '<span style>' + number + ' parts made. ' + quorum + ' required to reconstruct</span>';
		partsInBox = true
	};
	document.getElementById("partsIn").style.display = "none";
	document.getElementById("shadow").style.display = "none"
};

function displayshare(shares,quorum){
	var length = shares[0].length,
		quorumst = "00" + quorum,
		tagsOff = document.getElementById("notags").checked;
		quorumst = quorumst.substr(quorumst.length-3);
		
	//strip initial "8" and display each share in a new line, base 64, with tags
	if(!tagsOff){	
		var	output = "PL17p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '') + "=PL17p" + quorumst;	
	
	//trim final "=" and display with tags
	}else{
		var	output = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '')
	}
	for (var i=1; i < shares.length; i++) {
		if(!tagsOff){
			output = output + "\n\n" + "PL17p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '') + "=PL17p" + quorumst;
		}else{
			output = output + "\n\n" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '')
		}
	};	
	document.getElementById('mainBox').value = output;
};

//this looks for a string in the blacklist array and refuses to take it as a Key or decoy password if it is found there
function checkBlacklist(string){
//this makes an array with the 500 most frequent passwords as of 2008, from www.whatsmypass.com/the-top-500-worst-passwords-of-all-time, plus a few more
var blacklist = "i2e4sg password i2e4sgtb i2e4 pussy i2e4s dragon qwerty gggggg mustang letmein baseball master michael football shadow monkey abci2e pass fuckme gggg jordan harley ranger iwantu jennifer hunter fuck 2ooo test batman trustnoi thomas tigger robert access love buster i2e4sgt soccer hockey killer george sexy andrew charlie superman asshole fuckyou dallas jessica panties pepper iiii austin william daniel golfer summer heather hammer yankees joshua maggie biteme enter ashley thunder cowboy silver richard fucker orange merlin michelle corvette bigdog cheese matthew i2i2i2 patrick martin freedom ginger blowjob nicole sparky yellow camaro secret dick falcon taylor iiiiii ieieie i2ei2e bitch hello scooter please porsche guitar chelsea black diamond nascar jackson cameron gs4e2i computer amanda wizard xxxxxxxx money phoenix mickey bailey knight iceman tigers purple andrea horny dakota aaaaaa player sunshine morgan starwars boomer cowboys edward charles girls booboo coffee xxxxxx bulldog nccitoi rabbit peanut john johnny gandalf spanky winter brandy compaq carlos tennis james mike brandon fender anthony blowme ferrari cookie chicken maverick chicago joseph diablo sexsex hardcore willie welcome chris panther yamaha justin banana driver marine angels fishing david maddog hooters wilson butthead dennis fucking captain bigdick chester smokey xavier steven viking snoopy blue eagles winner samantha house miller flower jack firebird butter united turtle steelers tiffany zxcvbn tomcat golf bondoot bear tiger doctor gateway gators angel junior thxiieb porno badboy debbie spider melissa booger i2i2 flyers fish porn matrix teens scooby jason walter cumshot boston braves yankee lover barney victor tucker princess mercedes siso doggie zzzzzz gunner horney bubba 2ii2 fred johnson xxxxx tits member boobs donald bigdaddy bronco penis voyager rangers birdie trouble white topgun bigtits bitches green super qazwsx magic lakers rachel slayer scott 2222 asdf video london tttt marlboro srinivas internet action carter jasper monster teresa jeremy iiiiiiii bill crystal peter pussies cock beer rocket theman oliver prince beach amateur ttttttt muffin redsox star testing shannon murphy frank hannah dave eaglei iiiii mother nathan raiders steve forever angela viper oubi2 jake lovers suckit gregory buddy whatever young nicholas lucky helpme jackie monica midnight college baby cunt brian mark startrek sierra leather 2e2e2e 4444 beavis bigcock happy sophie ladies naughty giants booty blonde fucked golden o fire sandra pookie packers einstein dolphins o chevy winston warrior sammy slut bgtseog zxcvbnm nipples power victoria asdfgh vagina toyota travis hotdog paris rock xxxx extreme redskins erotic dirty ford freddy arsenal accessi4 wolf nipple iloveyou alex florida eric legend movie success rosebud jaguar great cool cooper ieie scorpio mountain madison gbtgs4 brazil lauren japan naked squirt stars apple alexis aaaa bonnie peaches jasmine kevin matt qwertyui danielle beaver 4e2i 4i2b runner swimming dolphin gordon casper stupid shit saturn gemini apples august eeee canada blazer cumming hunting kitty rainbow ii22ee arthur cream calvin shaved surfer samson kelly paul mine king racing ssss eagle hentai newyork little redwings smith sticky cocacola animal broncos private skippy marvin blondes enjoy girl apollo parker qwert time sydney women voodoo magnum juice abgrtyu tttttt dreams maxwell music rush2ii2 russia scorpion rebecca tester mistress phantom billy gggg albert asdfg zxcvb passwordi opensesame ggg i2e4sgtbg i2e4sgtbgo key keys lock locks mykey masterkey passlok passlock decoy decoypassword correcthorsebatterystaple".split(' ');

	var keymsg = document.getElementById("keymsg");			//take into account common substitutions, ignore spaces and case
	if(blacklist.indexOf(string.toLowerCase().replace(/[$5]/g,'s').replace(/[0]/g,'o').replace(/[@]/g,'a').replace(/[!1]/g,'i').replace(/[3]/g,'e').replace(/[7]/g,'t').replace(/[8]/g,'b').replace(/[69]/g,'g').replace(/\s/g,'')) != -1){
		if(document.getElementById("keyscr").style.display == "block"){
			keymsg.innerHTML = '<span style="color:purple">This is a known bad Key. Choose another</span>'
		} else if(document.getElementById("decoyIn").style.display == "block"){
			decoymsg.innerHTML = '<span style="color:purple">This is a known bad Password. Choose another</span>'
		}
		throw("Key blacklisted");
	}
}

//The following code is to convert the contents of main box into fake text, and backward. This can be useful against email scanners.

if (typeof code == 'undefined'){			//default text for base64 to words conversion, global variable
	var covertext = "The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.";
		covertext = covertext.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");	//remove multiple spaces, space after linefeed
	var code = covertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");
		code = code.filter(function(n){return n});													//remove nulls
		code = code.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});			//global array containing the words, no duplicates
	var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=~!@#$%" + "\n",	//base64 plus other characters used in PassLok strings
		remainder = code.length % keystr.length,
		noptions = Math.floor(code.length / keystr.length);
}

//This function checks for words or spaces encoding and calls the approrpiate decoders. If no encoding is detected, it calls the words encoder
function words(){
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if(document.getElementById('mainBox').value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()	
	}else{
		var text = document.getElementById('mainBox').value;											//get rid of null characters, if any
		if(text.trim() == ""){
			mainmsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text")
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			mainmsg.innerHTML = 'Message extracted from Words encoding'
		} else {																		//otherwise call words encoder
			toWords(text);
			mainmsg.innerHTML = 'Message encoded into words of this text. Decoding requires the same Cover text'
		}
	}
}

//this is almost the same as above, but if it doesn't detect encoding present, it calls the spaces encoder instead
function spaces(){
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if(document.getElementById('mainBox').value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()
	}else{
		var text = document.getElementById('mainBox').value;
		if(text.trim() == ""){
			mainmsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text");
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			mainmsg.innerHTML = 'Message extracted from Words encoding'
		} else {																		//otherwise call spaces encoder
			toSpaces();
			if(mainmsg.innerHTML=="") mainmsg.innerHTML = 'Message encoded into spaces of this text. Decoding does not require the same Cover text'
		}
	}
}

//the following two are to encode or decode each character of the main box into a word from the covertext
function toWords(text){
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The contents of the main box will be replaced with fake text containing it in encoded form. The recipient must have the same Cover text. Cancel if this is not what you want.");
			if(reply===false) throw("toWords canceled");
	}
		var output = code[randomindex(keystr.indexOf(text[0]))];
		for (var i = 1; i < text.length; i++){
			var index = keystr.indexOf(text[i]);
			if(index == -1){
				mainmsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 
				throw("illegal characters in the main box")
			}
			output = output + randompunct() + code[randomindex(index)]					//add some random commas and periods, and spaces between words
		}
		//capitalize initial and after period, add final period.
		output = output.replace(/[.][\s\n][a-z]/g,function(a){return a.toUpperCase();}).replace(/[a-z]/,function(a){return a.toUpperCase();}) + ".";
		document.getElementById('mainBox').value = output
}

function fromWords(indices){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The encoded text in the main box will be replaced with the original text from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}
		var output = "";
		for (var i = 0; i < indices.length; i++){
			output = output + keystr[indices[i] % keystr.length]
		}
		document.getElementById('mainBox').value = output		
}

//Computes an index taking the full range of words in the covertext
function randomindex(index){
	if(index >= remainder){
		var choice = Math.floor(Math.random() * noptions)
	}else{
		var choice = Math.floor(Math.random() * (noptions + 1))
	}
	return index + choice*keystr.length
}

//To find words in the code. Returns the index if found, or -1 if not found
function searchStringInArray (str, strArray) {
    for (var j = 0; j < strArray.length; j++) {
        if (strArray[j] == str) return j;
    }
    return -1;
}

//This is to generate random periods, commans and newlines, per the percentage brackets below, plus spaces when appropriate
function randompunct(){
	var percent = Math.ceil(Math.random() * 100);
	if (percent < 7) {
		return ". "
	} else if(percent < 13) {
		return ", "
	} else if(percent < 14) {
		return ".\n"	
	} else {
		return " "
	}
}

//the following functions are to hide text into a text cover, as binary double spaces. It needs 7 cover words for each ASCII characters, 42 for non-ASCII
function encoder(bin){
	var textsplit = covertext.split(" ");
	var spaces = textsplit.length - 1;
	var missing = bin.length - spaces;
	var turns = 0;
	if (spaces < bin.length){
		while (spaces < bin.length){
			textsplit = textsplit.concat(covertext.split(" "));
			spaces = textsplit.length - 1;
			turns = turns + 1
		}
		mainmsg.innerHTML = '<span style="color:red">The cover text was too short. It was repeated ' + turns + ' times. If this is not acceptable, repeat with a larger cover.</span>'; 
	}
		textsplit = textsplit.slice(0,bin.length+2);
	var newtext = textsplit[0];
	for(var i=0; i < textsplit.length-1; i++){
		newtext = newtext + stegospace(bin.slice(i,i+1)) + textsplit[i+1]
	}
	return newtext
}

function decoder(text){
	var bin = "";
	var textsplit = text.split(" ");
	for(var i=1; i < textsplit.length-1; i++){
		if (textsplit[i] == ""){
			bin = bin + "1";
			i = i + 1					//skip next word
		}else{
			bin = bin + "0"
		}
	}
	return bin
}

function stegospace(bin){
	if(bin == "1"){
		return "  "						//double space
	}else{
		return " "						//regular space
	}
}

function toSpaces() {
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The contents of the main box will be replaced with encoded text which contains the original text as irregular spacing. Cancel if this is not what you want.");
		if(reply===false) throw("toSpaces canceled");
	}	
  var output=""; 
	var input = document.getElementById('mainBox').value.trim();
    for (var i=0; i < input.length; i++) {
		if(keystr.indexOf(input[i]) == -1){
			mainmsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 			
			throw("illegal characters in the main box")
		}
		var bin = "000" + input[i].charCodeAt(0).toString(2);
        output = output + bin.slice(bin.length-7,bin.length);
    }
	document.getElementById('mainBox').value = encoder(output)
}

function fromSpaces() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The encoded text in the main box will be replaced with the original text from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}
	var mainmsg = document.getElementById("mainmsg");
	var output=""; 
	var input=decoder(document.getElementById('mainBox').value);
    for (var i=0; i < input.length; i=i+7) {
		var bin = input.slice(i,i+7);
        output = output + String.fromCharCode(parseInt(bin,2));
    }
	document.getElementById('mainBox').value = output.replace(/\x00/g,'');							//take out nulls, in case text was added to finish the last sentence.
	mainmsg.innerHTML = 'Message extracted from Spaces encoding'
}

//this one is to display the cover text or change it as requested
function newcover(string){
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
	if(string.trim() == ""){														//if the box is empty display the cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The cover text will be displayed in the main box. Cancel if this is not what you want.");
			if(reply==false) throw("covertext display canceled");
		}	
		document.getElementById('mainBox').value = covertext
	}else{																			//otherwise store new cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("If you go ahead, the cover text will be replaced with the contents of this box, which will be deleted.");
			if(reply==false) throw("covertext change canceled");
		}	
		var newcovertext = string.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");				//remove multiple spaces, spaces after linefeed
		if (newcovertext.match(/[\u3400-\u9FBF]/) != null) newcovertext = newcovertext.split('').join(' ').replace(/  +/g, ' ');		//add spaces if Chinese, Korean, or Japanese
		var	newcode = newcovertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");  	//removes punctuation, collapses spaces to single space
			newcode = newcode.filter(function(n){return n});																			//remove nulls
			newcode = newcode.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});									//remove repeats
		if (newcode.length >= keystr.length){										//enough length for words method
			code = newcode;															//store into global variables
			covertext = newcovertext;			
			remainder = code.length % keystr.length;
			noptions = Math.floor(code.length / keystr.length);
			document.getElementById('mainBox').value = "";
			mainmsg.innerHTML = 'Cover text changed'
		} else {
			mainmsg.innerHTML = '<span style="color:red">This text is too short for a Cover</span>';
			throw("text sample too short");
		}	
	}
}      

//get name and Lock from form and merge them with the lockDB object, then store
function addLock(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item in the box will be added to the permanent directory. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB add canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	var name = document.getElementById('locknameBox').value.trim(),
		lock = document.getElementById('lockBox').value.trim();
	if (lock ==''){
		var ran = true;
		lock = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,86);   //make a random Key and store it below if a name is provided
		document.getElementById('lockBox').value = lock;
	}
	if (name !=''){
		var key = readKey();
			lock = '~' + keyEncrypt(key,lock);												//add prefix so it can be identified as encrypted
		var newEntry = JSON.parse('{"' + name + '":["' + lock + '"]}');
			lockDB = sortObject(mergeObjects(lockDB,newEntry));
			localStorage.lockDB = JSON.stringify(lockDB);
			lockNames = [''].concat(Object.keys(lockDB));
			
			if(testChromeSync()){											//if Chrome sync is available, add to sync storage
				syncChromeLock(name,'["' + lock + '"]')
			}
			
		if (ran) {lockmsg.innerHTML = 'Random Key stored'} else {lockmsg.innerHTML = 'Item stored'}
	} else {
		lockmsg.innerHTML = '<span style="color:red">Cannot save without a name</span>'	
	};
	suspendFindLock = false
	
//this for phonegap only
	if(navigator.contacts){
		// create a new contact
    	var contact = navigator.contacts.create();

    	// store contact Lock in ContactField[]
		contact.name = name;
    	contact.lock = new ContactField('Lock', lock, true);

    	// save the contact
    	contact.save();
	}
}

//delete a particular key in Object lockDB, then store
function removeLock(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item displayed in the box will be removed from the permanent directory. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB remove canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	var name = lockmsg.innerHTML;
	if (lockDB[name] == null){
		lockmsg.innerHTML = 'To remove an item, its name must be displayed <strong>here</strong>';
		throw('bad name')
	}
	delete lockDB[name];
	localStorage.lockDB = JSON.stringify(lockDB);
	lockNames = [''].concat(Object.keys(lockDB));
	
		if(testChromeSync()){											//if Chrome sync is available, remove from sync storage
				if(confirm('Item removed from local storage. Do you want to remove it also from the Chrome sync area?')) remChromeLock(name)
		}	
	
	lockmsg.innerHTML = name + ' deleted';
	suspendFindLock = false
}

//this is to just delete the PFS data for a particular key (or reset the current list)
function resetPFS(){
	var lockmsg = document.getElementById("lockmsg");
	if (document.getElementById('lockBox').value.trim().split('\n').length > 1){		//use button to reset current list if a list is displayed, nothing to do with normal use
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The list currently being formed will be reset. Cancel if this is not what you want.");
			if(reply==false) throw("List reset canceled");
		}
		currentList = '';
		lockmsg.innerHTML = 'Current list reset';
		return
	}															
	if (document.getElementById("learnmode").checked === true){			//now the real stuff
		var reply = confirm("The data needed to maintain a PFS conversation with this sender/recipient will be deleted, so the ongoing conversation cannot be continued. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("myself reset canceled");
	}
	var name = lockmsg.innerHTML;
	if (lockDB[name] == null){
		lockmsg.innerHTML = 'The item to be reset must be displayed first';
		throw('bad name')
	}
	if ((lockDB[name][1] == null) && (lockDB[name][2] == null) && (lockDB[name][3] == null)){
		lockmsg.innerHTML = 'Nothing to reset';
		throw('no PFS data')
	}
	lockDB[name].splice(1,4);
	localStorage.lockDB = JSON.stringify(lockDB);
	
		if(testChromeSync()){											//if Chrome sync is available, change in sync storage
			syncChromeLock(name,JSON.stringify(lockDB[name]))
		}	
	
	lockmsg.innerHTML = 'PFS data for ' + name + ' deleted';
	suspendFindLock = false
}

var suspendFindLock = false
//searches for name in Locks database and returns the Lock, displays full name as well. Invoked as the user types
function findLock(){
	var lockmsg = document.getElementById("lockmsg");
	lockmsg.innerHTML = '';
	var string = document.getElementById('locknameBox').value;
	var index = searchStringInArrayDB(string,lockNames);
	if (index > 0){
		var name = lockNames[index];
		lockmsg.innerHTML = name;
		document.getElementById('lockBox').value = lockDB[name][0]
	}else{
		lockmsg.innerHTML = '';
		document.getElementById('lockBox').value = ''
	}	
}

//if a newline is entered, puts the expanded contents of the name box in the lock box, and waits for another item
var currentList = '';

function addToList(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item displayed will be added to the current list. Cancel if this is not what you want.");
		if(reply==false) throw("add to list canceled");
	}
	var lockmsg = document.getElementById("lockmsg"),
		currentItem = document.getElementById('lockBox').value;
	if(lockmsg.innerHTML != ''){
		var namenumber = currentItem.split('\n').length
		if (namenumber > 1 || document.getElementById('locknameBox').value==''){	//if the item is itself a list or there is no name, add the contents rather than the displayed name
			if(currentList == ''){	
				currentList = currentItem
			}else{
				currentList = currentList + '\n' + currentItem				
			}
			lockmsg.innerHTML = namenumber + ' items added to the current list'
		} else {
			if(currentList == ''){
				currentList = lockmsg.innerHTML				
			}else{
				currentList = currentList + '\n' + lockmsg.innerHTML
			}
			lockmsg.innerHTML = lockmsg.innerHTML + ' added to the current list'
		}
	} else {
		if (currentList !=''){
			lockmsg.innerHTML = 'This is the (temporary) current list'
		} else {
			lockmsg.innerHTML = 'No items on the current list'
		}
	}
	var listArray = currentList.replace(/\n+/g,'\n').split('\n');
	listArray = listArray.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});	//remove duplicates
	currentList = listArray.join('\n');
	document.getElementById('lockBox').value = currentList.trim();
	currentList = document.getElementById('lockBox').value;
	suspendFindLock = false
}

//automatically decrypts an item stored encrypted in the lockDB database. It uses the permanent Key
function decryptItem(){
	var	key = readKey(),
		string = document.getElementById('lockBox').value.trim();
	if(string == "") throw('nothing to decrypt');
	string = string.slice(1,string.length);															//strip initial '~'
	document.getElementById('lockBox').value = keyDecrypt(key,string);
	document.getElementById("mainmsg").innerHTML = 'Item ready'
}

//add a few spaces and newlines, then remove brackets, etc., extra spaces, put in alphabetical order
function showLockDB(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The complete directory of Locks, shared Keys, etc. stored in this device will be displayed. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB show canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	if(localStorage.lockDB != "{}"){		
		var alphalockDB = lockDB;
		document.getElementById('lockBox').value = JSON.stringify(alphalockDB,null,4).replace(/[{}"\[\]]/g,'').replace(/\n    /g,'\n').replace(/ \n/g,'\n').replace(/,\n/g,'\n').trim();
		lockmsg.innerHTML = 'These are the items stored in this device';
	}else{
		lockmsg.innerHTML = '<span style="color:red">There are no stored items</span>';
	}
	suspendFindLock = false
}

//reconstruct the original JSON string from the newlines and spaces as displayed by showLockDB
function mergeLockDB(){
	var learnOn = document.getElementById("learnmode").checked === true;
	
	var lockmsg = document.getElementById("lockmsg"),	
		lockstr = document.getElementById('lockBox').value.trim(),				//see if these are Locks for a possible DH merge, which is not the main function of this button
		mainstr = document.getElementById('mainBox').value.trim();
	if (lockstr == ''){
		lockmsg.innerHTML = 'Nothing to merge';
		throw('invalid merge')
	}
	if (lockstr.slice(0,1) == '~') {
		var key = readKey();
		lockstr = keyDecrypt(key,lockstr.slice(1,lockstr.length))
	}
	var lockstr2 = striptags(lockstr),
		mainstr2 = striptags(mainstr);
	if((lockstr2.length == 87 && mainstr2.length == 87) || (lockstr2.length != 87 && mainstr2.length != 87 && lockstr.split('\n').length == 1)){
		lockmsg.innerHTML = '<span style="color:orange">One and only one of the items to be merged must be a Lock<span>';
		throw('invalid DH merge')
	}
	if (lockstr2.length == 87){							//if it's a Lock in the lock box, merge it with the Key, clear lock box so it doesn't get merged next time
		if (mainstr == ''){
			lockmsg.innerHTML = 'Nothing to merge this Lock with';
			throw('invalid merge')
		}
		if (learnOn){
			var reply = confirm("The Lock in the Locks box will be combined with the Key in the main box, and the resulting Key will replace both. Cancel if this is not what you want.");
			if(reply===false) throw("merge canceled");
		};
		document.getElementById('mainBox').value = makeshared(mainstr,lockstr2);
		document.getElementById('lockBox').value = document.getElementById('mainBox').value;
		lockmsg.innerHTML = 'Lock merged with Key in main box';
		throw ("it was a lock, merged with key")
	} else if (mainstr2.length == 87 && lockstr.split('\n').length == 1 && lockstr!=''){		//if it's a Lock in the main box and not multiline in the lock box
		if (learnOn){
			var reply = confirm("The Key in the Locks box will be combined with the Lock in the main box, and the resulting Key will replace both. Cancel if this is not what you want.");
			if(reply===false) throw("merge canceled");
		};
		document.getElementById('mainBox').value = makeshared(lockstr,mainstr2);
		document.getElementById('lockBox').value = document.getElementById('mainBox').value;
		lockmsg.innerHTML = 'Key merged with Lock in main box';
		throw ("it was a key, merged with lock")
		
	} else if(lockstr.split('\n').length > 1){
		
	//now the real database merge, which implies multiline
	if (learnOn){
		var reply = confirm("The items in the box will be merged into the permanent directory, replacing existing items of the same name. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB merge canceled");
	}
	var newDB = JSON.parse('{"' + document.getElementById('lockBox').value.trim().replace(/\n +/g,'\n').replace(/:\n/g,'":["').replace(/\n\n/g,'"],"').replace(/\n/g,'","') + '"]}');
		lockDB = sortObject(mergeObjects(lockDB,newDB));
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
		lockmsg.innerHTML = 'Items merged into database';
		
		if(testChromeSync()){
			for(var name in lockDB){										//if Chrome sync is available, change all this in sync storage
				syncChromeLock(name,JSON.stringify(lockDB[name]))
			}
		}
	}
	suspendFindLock = false
}

//makes encrypted backup of the whole DB, then if allowed clears lockDB object, then stores
function moveLockDB(){
	var lockmsg = document.getElementById("lockmsg");
	var key = readKey();
	
	//first encrypt lockDB, as displayed by showLockDB
	showLockDB();
	document.getElementById('mainBox').value = 'PL17dir=~' + keyEncrypt(key,document.getElementById('lockBox').value.trim()) + '=PL17dir';
	lockmsg.innerHTML = '<span>Database in main screen</span>'
	
	//now check that the user really wants to delete the database
	var answer = confirm("The database has been exported to the main screen. If you go ahead, it will now be erased from this device. This cannot be undone.");
	if (answer == false) throw("lockDB erase canceled");
		lockDB = {};
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
		lockmsg.innerHTML = '<span style="color:purple">Stored items erased</span>';
	suspendFindLock = false
}

//merges two objects; doesn't sort the keys
function mergeObjects(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
}

//sorts object keys alphabetically
function sortObject(o) {
    var sorted = {},
    	key, a = [];
    for (key in o) {
    	if (o.hasOwnProperty(key)) {
    		a.push(key);
    	}
    }
    a.sort(insensitive);							//this depends on next function
    for (key = 0; key < a.length; key++) {
    	sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

//to make sorting case-insensitive
function insensitive(s1, s2) {
  var s1lower = s1.toLowerCase();
  var s2lower = s2.toLowerCase();
  return s1lower > s2lower? 1 : (s1lower < s2lower? -1 : 0);
}

//finds first partial match of string str and returns index of array element
function searchStringInArrayDB (str, strArray) {
	var reg = new RegExp(str, "i");					//make it case-insensitive
    for (var j=0; j<strArray.length; j++) {
		if (strArray[j] != null){
    		if (strArray[j].match(reg)) return j;
		}
    }
    return -1;
}

//global variable used for key box expiration
var keytimer = 0;

//add entropy as forms are manipulated, reset key boxes after 5 minutes
function ce() {
	sjcl.random.addEntropy(Math.floor((((new Date).getMilliseconds()) * 255) / 999), 2, "loadtime");
};

//now comes the code dealing with page formatting and such

//this is for showing and hiding text in key box and other password input boxes
function showsec(){
  var showPasswordCheckBox = document.getElementById("showKey");
  if(showPasswordCheckBox.checked){
        document.getElementById('pwd').type="TEXT";
  }else{
      document.getElementById('pwd').type="PASSWORD";
  }
};

function showdecoyIn(){
  var showPasswordCheckBox = document.getElementById("showdecIn");
  if(showPasswordCheckBox.checked){
        document.getElementById('decoyPwdIn').type="TEXT";
  }else{
      document.getElementById('decoyPwdIn').type="PASSWORD";
  }
};

function showdecoyOut(){
  var showPasswordCheckBox = document.getElementById("showdecOut");
  if(showPasswordCheckBox.checked){
        document.getElementById('decoyPwdOut').type="TEXT";
  }else{
      document.getElementById('decoyPwdOut').type="PASSWORD";
  }
};

function showIntro(){
  var showPasswordCheckBox = document.getElementById("showIntroKey");
  if(showPasswordCheckBox.checked){
        document.getElementById('pwdIntro').type="TEXT";
  }else{
      document.getElementById('pwdIntro').type="PASSWORD";
  }
};

function box2cover(){
	newcover(document.getElementById('mainBox').value)
}

//for selecting text in main and extra screens
function selectMain(){
	document.getElementById('mainBox').selectionStart=0;
	document.getElementById('mainBox').selectionEnd=document.getElementById('mainBox').value.length;
}
function clearMain(){
	document.getElementById('mainBox').value = '';
	document.getElementById('mainmsg').innerHTML = '';
}
function clearLocks(){
	document.getElementById('lockBox').value='';
	document.getElementById('locknameBox').value='';
	document.getElementById('lockmsg').innerHTML='';
	suspendFindLock = false;
}
function clearKey(){
	document.getElementById('pwd').value = '';
	document.getElementById('keymsg').innerHTML = 'The Key has been reset';
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("Your Lock stored in the database will now be erased so it can be re-written. Cancel if this is not what you want.");
			if(reply==false) throw("Key reset canceled");
	}
	delete lockDB['myself'];
	localStorage.lockDB = JSON.stringify(lockDB);	
}
function clearIntro(){
	document.getElementById('pwdIntro').value = '';
	document.getElementById('keyIntromsg').innerHTML = '';
	document.getElementById('pwd').value = '';
	document.getElementById('keymsg').innerHTML = '';
}
function openmainhelp(){
	openClose('mainscr');
	openClose('mainhelp');
}
function openextrahelp(){
	openClose('mainscr');
	openClose('extrahelp');
}
function openlockhelp(){
	openClose('lockscr');
	openClose('lockhelp');
}
function openkeyhelp(){
	openClose('keyhelp');
}
function closemainhelp(){
	openClose('mainhelp');
	openClose('mainscr');
}
function closeextrahelp(){
	openClose('extrahelp');
	openClose('mainscr');
}
function closelockhelp(){
	openClose('lockhelp');
	openClose('lockscr');
}
function openquiz(){
	openClose('mainhelp');
	openClose('quiz');
}
function closequiz(){
	openClose('quiz');
	openClose('mainhelp');
}
function exitKey(){
	checkBlacklist(document.getElementById('pwd').value);
	key2any();
}
function makelockIntro(){
	checkBlacklist(document.getElementById('pwd').value);
	document.getElementById('pwd').value = document.getElementById('pwdIntro').value
	fillkeys();
	key2any();
	openClose('introscr');
	openClose('mainscr');
}
//closes input divs
function closebox() {
	document.getElementById("shadow").style.display = "none";
	document.getElementById("decoyIn").style.display = "none";
	document.getElementById("decoyOut").style.display = "none";
	document.getElementById("partsIn").style.display = "none";
	document.getElementById("keyscr").style.display = "none"
}

function locknameKeyup(){
	if (event.keyCode == 13) {												//sync from Chrome or decrypt if hit Return
		var name = document.getElementById("locknameBox").value;
		if(document.getElementById("lockmsg").innerHTML == ''){				//found nothing, so try to get it from Chrome sync
			if(testChromeSync()){
				getChromeLock(name);
			} else {															//try to find it in mobile contacts
			
	//this for phonegap only
				if(navigator.contacts){
	// find all contacts with 'name' in any name field
					var gapoptions      = new ContactFindOptions();
					gapoptions.filter   = name;
					gapoptions.multiple = true;
					var fields       = ["displayName", "name"];
					navigator.contacts.find(fields, onContactSuccess, onContactError, gapoptions);
				}			
				
			}
		} else {
			if(!document.getElementById("lockmsg").innerHTML.match('not found in your Chrome')) decryptItem()		//decrypt 1st time if found locally, 2nd time if synced from Chrome
		}
	} else if (!suspendFindLock){return findLock()};
}

//the following two functions are for phonegap only
function onContactSuccess(contacts) {
	if(navigator.contacts.lock){
		document.getElementById("lockmsg").innerHTML = name;
		document.getElementById('lockBox').value = navigator.contacts.lock
	} else {
		document.getElementById("lockmsg").innerHTML = 'No Lock found for ' + name + ' in Contacts';
	}
};

function onContactError(contactError) {
    document.getElementById("lockmsg").innerHTML = name + ' not found in Contacts'
};

function pwdKeyup(){
	clearTimeout(keytimer);
	keytimer = setTimeout(function() {document.getElementById('pwd').value = ''}, 300000);
	if (event.keyCode == 13){exitKey()} else return keyStrength(document.getElementById('pwd').value,true);
}
function introKeyup(){
	return keyStrength(document.getElementById('pwdIntro').value,true);
}
function decoyKeyup(){
	if (event.keyCode == 13){submitDecoyIn()} else return keyStrength(document.getElementById('decoyPwdIn').value,true);
}
function submitDecoyIn(){
	checkBlacklist(document.getElementById('decoyPwdIn').value);
	closebox();
	if(encrypting){Decrypt_text()}else{Verifyhash()};
}
function decoyKeyupOut(){
	if (event.keyCode == 13){submitDecoyout()};
}
function submitDecoyOut(){
	closebox();
	if(encrypting){Decrypt_text()}else{Verifyhash()};
}
function partsKeyup(){
	if (event.keyCode == 13){submitParts()};
}
function submitParts(){
	if(!isNaN(document.getElementById('partsNumber').value)){
	closebox();
	secretshare();
	}
}

//for switching between windows
function main2extra(){
	openClose("mainbuttonstop");
	openClose("mainbuttonsbot");
	openClose("extrabuttonstop");
	openClose("extrabuttonsbot");
}
function extra2main(){
	openClose("extrabuttonstop");
	openClose("extrabuttonsbot");
	openClose("mainbuttonstop");
	openClose("mainbuttonsbot");
}
function main2lock(){
	openClose("mainscr");
	openClose("lockscr");
	fromMain = false;
}
function lock2main(){	
	if(document.getElementById('lockBox').value.slice(0,1) == '~') {
		decryptItem();
	}
	openClose('lockscr');
	openClose('mainscr');
	fromMain = true;
	if(document.getElementById('lockBox').value != '') document.getElementById("mainmsg").innerHTML = 'Item ready';
	if(document.getElementById('lockBox').value.split(' ').length >= keystr.length){
		newcover(document.getElementById('lockBox').value);					//this for loading cover text from lock screen
		document.getElementById("mainmsg").innerHTML = 'Cover text changed'
	}
}

function image2extra(){
	openClose('imagescr');
	openClose('mainscr');
}

fromMain = true;						//directory frame was accessed from main screen unless set otherwise
function lock2dir(){
	loadLockDir();
	openClose('lockscr');
	openClose('lockdir');
	fromMain = false;
}
function dir2lock(){
	openClose('lockdir');
	if(fromMain){openClose('mainscr')} else {openClose('lockscr')};
}
function any2key(){
	document.getElementById("keyscr").style.display = "block";
	document.getElementById("shadow").style.display = "block";	
}
function key2any(){
	clearTimeout(keytimer);
	keytimer = setTimeout(function() {document.getElementById('pwd').value = ''}, 300000)	//reset timer for 5 minutes, then delete Key
	
	closebox();
	var mykey = document.getElementById('pwd').value.trim();
	if(lockDB['myself'] == null && mykey != ''){					//if "myself" lockDB entry containing the Key's matching Lock is not present, add it
		var mylock = makepub(mykey);
		mylock = '~' + keyEncrypt(mykey,mylock);
	var newEntry = JSON.parse('{"myself":["' + mylock + '"]}');
		lockDB = mergeObjects(lockDB,newEntry);
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
	}
}

function addSupport(){
	var key = readKey(),
		name = "PassLok support",
		lock = "PL17lok=SCh77O0wzIgKuNjct+vV7RJifPi18r5zJUfPonx5WbnrnJ9iPaypXYT+NCp1RrVKykIOTe7Jg5pa2UW5FipUWwN=PL17lok";
		lock = '~' + keyEncrypt(key,lock);
	var newEntry = JSON.parse('{"' + name + '":["' + lock + '"]}');
		lockDB = sortObject(mergeObjects(lockDB,newEntry));
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
			
		if(testChromeSync()){											//if Chrome sync is available, add to sync storage
			syncChromeLock(name,'["' + lock + '"]')
		}
	document.getElementById('support').style.color = "green"
}

//to see if there is a Chrome sync data area. Works for Chrome apps and extensions
function testChromeSync(){
	if(chrome.storage){
		if(chrome.storage.sync){
			return true
		} else {return false}
	} else {return false}
}

<!-- Text hide trick, by Sandeep Gangadharan 2005-->
if (document.getElementById) {
 document.writeln('<style type="text/css"><!--')
 document.writeln('.texter {display:none} @media print {.texter {display:block;}}')
 document.writeln('//--></style>') }

function openClose(theID) {
 if (document.getElementById(theID).style.display === "block") { document.getElementById(theID).style.display = "none" }
 else { document.getElementById(theID).style.display = "block" } };
// end of hide trick

//to load Lock directory only once
function loadLockDir(){
	if(document.getElementById('lockdirframe').src != 'https://passlok.com/lockdir') document.getElementById('lockdirframe').src = 'https://passlok.com/lockdir';
}

//The main script in the head ends here.

//special funcitons that work only with Chrome apps and extensions

//to put Lock into sync storage
function syncChromeLock(name,data) {
    var jsonfile = {};
    jsonfile[name.toLowerCase()] = data;
    chrome.storage.sync.set(jsonfile);
}

//to retrieve Lock from sync storage. The code specifying what to do with the item is here because the get operation is asynchronous
function getChromeLock(name) {
    chrome.storage.sync.get(name.toLowerCase(), function (obj) {
		var lockdata = obj[name.toLowerCase()];
		if(lockdata){
			lockDB[name] = JSON.parse(lockdata);
			document.getElementById("lockBox").value = lockDB[name][0];
			document.getElementById("lockmsg").innerHTML = name + ' added from your Chrome sync area';
			localStorage.lockDB = JSON.stringify(lockDB);
			lockNames = [''].concat(Object.keys(lockDB));
		} else {
			document.getElementById("lockmsg").innerHTML = name + ' not found in your Chrome sync area'
		}
	});
}

//to completely remove an entry
function remChromeLock(name) {
    chrome.storage.sync.remove(name.toLowerCase());
}
</script>
		
</head>
  
<body link="#0000ff" vlink="#0000ff" alink="#0000ff">
  
<div id="mainscr" class="texter" style="display: block;">
  <div align="center">
		<input type="text" class="cssbox" id="warning" style="background-color: #FFB0B0; width: 60%; font-size: large; text-align: center" value="Javascript NOT working!" class="ctr" readonly/><br /><br />
	<span id="mainmsg"></span><br />
<div id="mainbuttonstop" class="texter" style="display: block;">
    <button class="cssbutton" id="myKeyButton" value="myKey" style="color:blue">myKey</button>
    <button class="cssbutton" id="main2lockButton" value="Locks" style="color:blue">Locks</button>   
	<button class="cssbutton" id="selectMainButton" value="Select" >Select</button>
	<button class="cssbutton" id="clearMainButton" value="Clear" >Clear</button>
</div>
<div id="extrabuttonstop" class="texter" style="display: none;">
		<button class="cssbutton" id="sendMailButton" value="Mail" >Mail</button>
        <button class="cssbutton" id="sendSMSButton" value="SMS" >Txt/Img</button>
        <button class="cssbutton" id="secretshareButton" value="Split/Join" >Splt/Jn</button>
        <button class="cssbutton" id="coverButton" value="Cover" >Cover</button>
</div>
    </div>
    <div align="center">
    		<textarea class="cssbox" id="mainBox" name="text" rows="13" style="width:96%;" placeholder="The text to be locked, unlocked, or signed goes here.   Before locking or verifying, you need to enter the other person's Lock by clicking the Locks button."></textarea>
    </div>
	<div align="center">
<div id="mainbuttonsbot" class="texter" style="display: block;">
    	<button class="cssbutton" id="openmainhelpButton" value="Help" style="color: #009400">Help</button>
    	<button class="cssbutton" id="decryptButton" value="Lock/Unlock" style="color:blue">Lck/Unl</button>
		<button class="cssbutton" id="verifyButton" value="Sign/Verify" >Sig/Ver</button>
    	<button class="cssbutton" id="main2extraButton" value="More" style="color:orange">&#x25B6;</button><br /><br />
        Mode:&nbsp;&nbsp;<input type="radio" name="lockmodes" id="anonmode" checked/>&nbsp; Anon.&nbsp;&nbsp;
        <input type="radio" name="lockmodes" id="signedmode"/>&nbsp; Signed&nbsp;&nbsp;
        <input type="radio" name="lockmodes" id="pfsmode"/>&nbsp; PFS&nbsp;&nbsp;
        <br /><br />
    	<input type="checkbox" id="shortmode"/>&nbsp; Short&nbsp;&nbsp;
    	<input type="checkbox" id="notags"/>&nbsp; No tags&nbsp;&nbsp;
        <input type="checkbox" id="decoymode"/>&nbsp; Decoy&nbsp;
</div>
<div id="extrabuttonsbot" class="texter" style="display: none;">
        <button class="cssbutton" id="openextrahelpButton" value="Help" style="color: #009400">Help</button>
    	<button class="cssbutton" id="wordsButton" value="Words" >Words</button>
		<button class="cssbutton" id="spacesButton" value="Spaces" >Spaces</button>
        <button class="cssbutton" id="extra2mainButton" value="Less" style="color:orange">&#x25C0;</button><br />
    <div align="center" id="fileIO">
    	<p>File In/Out (Chrome,Firefox,Safari)</p>
    	<input class="cssbutton" type="file" id="fileToLoad" style="width:85px"/>
        <input class="cssbutton" type="button" id="savefileButton" value="Save"/>
    </div>
</div>
  </div> 
</div>
    
<div id='imagescr' class="texter" style="display: none;" align="center">
    <button class="cssbutton" id="image2extraButton" value="< Back" >&#x25C0; Back</button>
    <button class="cssbutton" id="encode" value="Hide" >Hide</button>
    <button class="cssbutton" id="decode" value="Reveal" >Reveal</button><br /><br />
       
    <input class="cssbutton" type='file' id='file' style="width:85px"/><br /><br />
  
    <span id="imagemsg"></span><br />

    <img id="preview" src="" width="100%"/>

    <canvas id='canvas' style="display: none"></canvas>
    
</div> 

<div id="lockscr" class="texter" style="display: none;" align="center">
    <div align="center">
       <button class="cssbutton" id="lock2mainButton" value="< Back" style="float: left">&#x25C0; Back</button>
       <button class="cssbutton" id="lock2dirButton" value="Directory" style="width:140px">Lock directory</button>
       <button class="cssbutton" id="clearLocksButton" value="Clear" style="float: right">Clear</button><br /><br />
    </div> 
    <div align="center">
    	<span id="lockmsg"></span><br />
    	<input type="text" class="cssbox" id="locknameBox" style="width: 92%;" name="text" placeholder="Enter the name first, then enter the item in the large box."/></div><br /><br />
    <div align="center">
    	<button class="cssbutton" id="addLockButton" value="Save" >Save</button>
		<button class="cssbutton" id="removeLockButton" value="Del." >Delete</button>
        <button class="cssbutton" id="resetPFSButton" value="Reset" >Reset</button>
        <button class="cssbutton" id="addToListButton" value="List" >List</button>
    </div>
		<textarea class="cssbox" id="lockBox" style="width: 96%" name="text" rows="13" placeholder="Enter Locks and shared Keys here.   If the item has a name, first enter the name in the box above."></textarea>

	<div align="center">
        <button class="cssbutton" id="openlockhelpButton" value="Help" style="color: #009400">Help</button>
		<button class="cssbutton" id="showLockDBButton" value="All" >All</button>
        <button class="cssbutton" id="mergeLockDBButton" value="Merge" >Merge</button>
        <button class="cssbutton" id="moveLockDBButton" value="Move" >Move</button>
    </div>
</div> 
        
<div id="shadow" class="black_overlay" style="display: block;"></div>

<div id="keyscr" class="white_content" align="center" style="display: block;">
  	<div align="center">
    	<button class="cssbutton" id="exitKeyButton" value="< Back" style="float:left;;">&#x25C0; Close</button>
        <button class="cssbutton" id="clearKeyButton" value="Clear" style="float:right;">Reset</button>   	
    </div><br /><br />
    <div align="center">        
      		<span id="keymsg">First enter your Key</span><br /><br />
			<input type="password" class="cssbox" autocomplete="off" id="pwd" style="width: 92%" name="text" placeholder="Enter your secret Key here.  Then click Make Lock if you need to see your Lock." align="center"><br /><br />
    </div>
    <div align="center">
		<input type="checkbox" id="showKey" > Show 
        <button class="cssbutton" id="makelockButton" value="Make Lock" style="color:blue;width:110px">Make Lock</button><br /><br />
        <button class="cssbutton" id="openkeyhelpButton" value="Help" style="color: #009400">Help</button>
	</div>
    <div id="keyhelp" class="texter" align="left" style="width:98%;display: none;">        
      	<p>This is your secret Key, which gives you access to the rest of PassLok. You must memorize it and never write it down. As you type your Key, a text above it will tell you the strength of the Key based on simple rules. Make sure to <strong>use $ymbol$, numb3rs, caPiTals, unusual words and mispelingss.</strong> Initial capitals and numbers at start and end are not helpful and will be ignored for the strength score.</p>
		<p>If your Key strength is worse than Medium, <strong>PassLok will be very slow.</strong></p>
        <p>To display the characters, check <strong>Show</strong>.</p>
        <p>To display the matching Lock in the main screen, click the <strong>Make Lock</strong> button. Click it again to submit your Lock to the general directory.</p>
        <p>Clicking <strong>Reset</strong> erases the Key from the box and also erases its stored Lock.</p>
    </div>
</div>

<div id="introscr" class="texter" align="center" style="display: none;">
  	<h2 style="color:green">Welcome to PassLok</h2>
  <div align="left">
  	<p>If you have three minutes to spare, you may want to begin by watching this video, which explains the essential concepts in a lighthearted way.</p></div>
    <div align="center">
    <iframe id="videotutorial" seamless class="youtube-player" type="text/html" src=""></iframe></div>
   <div align ="left">
  	<p>So, the first thing you need to do is to come up with a strong secret <strong>Key</strong>, which will give you access to most of the functions. It will never be stored anywhere within the app. Please enter your Key in the box below.</p>
  	<p>As you type your Key, a text above it will tell you its strength based on simple rules. Make sure to <strong>use $ymbol$, numb3rs, caPiTals, unusual words and mispel ingss.</strong> Initial capitals and numbers at start and end  will be ignored for the strength score. To display the Key, check <strong>Show</strong>.</p>
    </div>
  	<div align="center">        
      		<span id="intromsg" style="color:green">This is where the score will appear</span><br /><br />
			<input type="password" class="cssbox" autocomplete="off" id="pwdIntro" style="width: 92%" name="text" placeholder="Enter your secret Key here." align="center"><br /><br />
    </div>
    <div align="center">
		<input type="checkbox" id="showIntroKey" > Show 
      <button class="cssbutton" id="clearIntroButton" value="Clear" >Clear</button>
      <br /><br />
	</div>
    <div class="texter" align="left" style="display: block;">
      	<p>Please take your time to come up with a strong Key. PassLok compensates for weak Keys by adding computations. If your Key strength is worse than Medium, <strong>PassLok will be very slow.</strong></p>       
      	<p>You will <strong>never give this Key to anyone</strong>. Instead, you will give them a <strong>Lock</strong> matching your Key. The Lock is made from the Key, but it is impossible to retrieve a Key from its matching Lock. A Lock consists of a series of 87 random-looking characters, bracketed by &quot;PL17lok&quot; tags.</p></div>
    <div align="center">
  <button class="cssbutton" id="makelockIntroButton" value="Make Lock" style="color:blue;width:140px" align="center">Make Lock</button>
  </div>
  <div class="texter" align="left" style="display: block;">
        <p>When you click the <strong>Make Lock</strong> button above, this screen will close and the Lock matching your Key will appear in PassLok's main screen, from where you can copy it, email it, text it, and even post it on PassLok's general directory.</p>
        <p>To lock a message so it turns into unreadable gibberish, the sender inputs the plain message in PassLok's main screen, then clicks <strong>Locks</strong> to get to the Locks screen, and puts <strong>the recipient's Lock</strong> in the big box there. Back at the main screen, the message is locked when the sender clicks <strong>Lck/Unl</strong>. The recipient unlocks the locked message by putting it in the main box and clicking <strong>Lck/Unl</strong>.</p>
        <p>The main screen, like all other screens in PassLok, has a <strong style="color:green">Help</strong> button that will give you complete instructions on how to do things.</p>
        <p>Please go ahead and write your secret Key in the box, then click the <strong>Make Lock</strong> button.</p>

    </div>
</div>
       
<div id="decoyIn" class="white_content" align="center">
    	<p>Enter the Decoy Password</p> 
		<span id="decoymsg"></span><br /> 
    	<input type="password" class="cssbox" id="decoyPwdIn" style="width: 98%" name="key"/>
		<p>Enter the Hidden Message</p>      
		<textarea id="decoyText" class="cssbox" style="width: 98%" name="text" rows="3"></textarea>
        <input type="checkbox" id="showdecIn" > Show
    	<button class="cssbutton" id="submitDecoyButton" value="OK" >OK</button>
		<button class="cssbutton" id="cancelDecoyButton" value="Cancel" >Cancel</button>  
</div>
       
<div id="decoyOut" class="white_content" align="center">
		<p>Enter the Decoy Password</p> 
    	<input type="password" class="cssbox" id="decoyPwdOut" style="width: 98%" name="key"/>
        <input type="checkbox" id="showdecOut" > Show   
    	<button class="cssbutton" id="submitDecoy2Button" value="OK" >OK</button>
		<button class="cssbutton" id="cancelDecoy2Button" value="Cancel" >Cancel</button>
    	<p>The Hidden message will appear on the main screen</p>  
</div>
    
<div id="partsIn" class="white_content" align="center">
		<p>Enter the total number of parts (between 2 and 255)</p> 
    	<input type="text" class="cssbox" id="partsNumber" style="width: 30%" name="text" rows="1"/><br />
		<p>And the number of parts needed to retrieve the item</p> 
    	<input type="text" class="cssbox" id="partsQuorum" style="width: 30%" name="text" rows="1"/><br /> <br />  
    	<button class="cssbutton" id="submitPartsButton" value="OK" >OK</button>
		<button class="cssbutton" id="cancelPartsButton" value="Cancel" >Cancel</button>
</div>

<div id="mainhelp" class="texter" style="display: none;">
 	<button class="cssbutton" id="closemainhelpButton" value="< Back" >&#x25C0; Back</button>
    <p>To get information on every button as you press it, check this box: <strong> Learn Mode <input type="checkbox" id="learnmode"/></strong></p>    
	<p>For instructions on how to do things, click on each title below. Click again to hide.</p>
    <p>If you would like to take the PassLok quiz, click this button: 
<button class="cssbutton" id="openquizButton" value="Quiz" style="width:140px">Go to Quiz</button>
</p>
    
  <hr style="background-color: #c0c0c0">
    
        <div id="aa1" style="cursor:pointer">
	<h3>I don't know how to start. Please help</h3>
    </div>
    <div id="a1" class="texter">
    <p>Before you do aything else, you may want to watch this six-minute video, which explains the essential concepts in a lighthearted way: <a href="https://www.youtube.com/watch?v=GqIm7fu_rMs" target="_blank">https://www.youtube.com/watch?v=GqIm7fu_rMs</a></p>
    <p>If you don't have time for the video, here's the two-paragraph version. PassLok locks messages and files, turning them into gibberish so only the intended recipients can return them to their original form and read them. It is based on digital Keys and Locks. A Lock is used to lock a message,  and then only the matching Key can unlock it so it becomes readable again. A Key is a piece of text that you choose and memorize; it is personal and should never be revealed to anyone. You make your Lock from your Key, and then you give it to people so they can lock messages for you to read.  It is impossible to get the Key from its matching Lock. Keys are to be kept <em>secret</em>, but Locks are made to be <em>widely distributed</em>. Locks look like gibberish but have tags at both ends of the form &quot;PL17lok&quot;.</p>
    <p>The first step is to come up with a secret Key that you can remember. You enter it in PassLok by clicking the <strong>myKey</strong> button. Then you make its matching Lock by clicking the <strong>Make Lock</strong> button on that screen. Then you click the <strong>Done</strong> button to go back to the main screen and see your Lock and copy it. You give this Lock to all the people you wish to write to you in secret. They will also send you their Locks, which you can store anywhere you want. To lock a message, the sender puts the plain message in the main box, then clicks <strong>Locks</strong> to get to the Locks screen, and puts the recipient's Lock in the big box there. Back at the main screen, the message is locked when the sender clicks <strong>Lck/Unl</strong> (Lock/Unlock). The recipient unlocks the locked message by putting it in the main box and clicking <strong>Lck/Unl</strong>. If the recipient had previously entered his/her secret Key, the original plain message is displayed.</p>
	<p>PassLok is very powerful, combining AES encryption with elliptic curves at the strongest levels defined by standards, and including several ways to hide the result from prying eyes. All processing occurs on your device with no server involved, so your privacy cannot be compromised by third parties. But great power means a lot of buttons.</p>
	<p>Fortunately, only four buttons are essential to get started. They are <span style="color:blue">highlighted in blue:</span></p>
    <p><span style="color:blue"><strong>myKey</strong></span> opens a dialog where you can enter your secret Key, which is needed for most advanced functions in PassLok. It is also needed to unlock messages locked with your personal Lock, which is not secret. To display this Lock, click the <strong>Make Lock</strong> button.</p>
    <p><span style="color:blue"><strong>Make Lock</strong></span> (visible after clicking myKey) creates the Lock matching the Key that has been entered in the Key dialog and writes it on the main screen, from where it can be copied, emailed, etc. Clicking a second time opens it in the general Lock directory, so you can post it for others to get or check that the posted Lock is still authentic.</p>
	<p><span style="color:blue"><strong>Locks</strong></span> opens a screen where you can enter somebody's Lock or shared Key, which is needed to lock the contents of the main box.</p>
	<p><span style="color:blue"><strong>Lck/Unl</strong></span> (abbreviated from Lock/Unlock) locks the plain message in the main box, or unlocks it if it was locked. The appropriate Lock or shared Key must have been entered previously by means of the <strong>Locks</strong> buttons.</p>
	
	<p>With these four buttons, you can get started locking and unlocking messages with very high security. Here's another video that shows this (made for version 1.6, though): <a href="https://www.youtube.com/watch?v=3wrhfzU4DFc" target="_blank">https://www.youtube.com/watch?v=3wrhfzU4DFc</a>    </p></div>
	<hr style="background-color: #c0c0c0">

    <div id="aa2" style="cursor:pointer">
<h3>Save PassLok to my device, so I don't have to download it again</h3>  
</div>
      <div id="a2" class="texter">
<p>PassLok is designed to save its code within the browser, so it only gets downloaded again if the code has changed. In the case of the Chrome packaged app, updates are automatic. Once PassLok has reached your device from its source server, it works even if the device is offline. Just make a bookmark on your browser so you can access it quickly. Still, you can make it behave even more like an app, this way:</p>
<p>1. If you are using a computer, you can direct the Browser to save the code to a local file via the "Save as..." command from the browser menu. Then you can place a link or shortcut to that file on your desktop. Even better than the "Save as..." command is to direct the browser to display the source (Ctrl-U or cmd-ctrl-U does it, on most devices and browsers), and then save the page that appears with the "Save as..." command. This way you'll save the original code rather than the code after it has been interpreted by the browser.</p>
<p>2. From an iOS device, it is as easy as loading PassLok on Safari, and then selecting "Add to Home Screen" from the box and arrow icon at the bottom of the screen. Be aware, however, that in this case PassLok will reset to its initial state every time you leave the app.</p>
<p>3. On Android, the same is typically achieved by first making a bookmark of the PassLok page, then tap-holding on the PassLok bookmark and selecting "Add to Home Screen." On some versions you can also tap-hold on the desktop screen and select "Add to Home Screen" followed by "Shortcut", "Bookmark", and selecting PassLok from the list. Newer versions of Android have still more direct ways to do this.</p>      
      </div>
 	<hr style="background-color: #c0c0c0">
    
      <div id="aa3" style="cursor:pointer">
<h3>Make a strong Key</h3>
</div>
	<div id="a3" class="texter">
<p>1. Click the <strong>myKey</strong> button, then start typing in the box. As you type, a text above the box will tell you
  how strong the Key is, based on simple rules. If you want to see what you
  are typing and don't mind people peering over your shoulder, check the
  Show checkbox.</p>
<p>2. The Key will be stronger if it contains <strong>caPiTals</strong> in unusual places,
  <strong>numb3rs</strong>, and <strong>$ymbol$</strong>. If you use common words, <strong>mispelll</strong> them to make harder a "dictionary attack." Avoid things that refer to yourself and your family, such
  as birthdays or nicknames, or anything else that might be easy to guess,
  like: asdfg, qwerty, password, PassLok, and the like.  Alternatively, you can use anything that is not a standard dictionary word instead of your email. PassLok knows the 500 most common English passwords. If your Key is found on this list, PassLok will refuse to accept it. Just choose another Key.</p>
<p>3. Bear in mind, however, that you should be able to <strong>remember
  your secret Key</strong> without having to write it down. PassLok will never
  ask you to change your Key, so this is your chance to make a truly strong Key
  that you will use for a long time.</p>
  <p>4. PassLok compensates for bad Keys by taking longer to do its computations. If PassLok is slow, this is likely because your Key strength is less than Medium.  </p>
  <p>5. If you change your Key after having used a different Key for a long time, be aware that any information stored locally, such as other people's Locks, shared Keys, etc. <strong>will become unavailable</strong>, leading to all sorts of problems. You may want to copy the items in your local directory to a different location, delete the database, and enter the items again after you change your Key.</p>
  <p>6. PassLok never stores your Key. As a matter of fact, it deletes it from the myKey box after five minutes of not being used.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=xPRiuBd9Co0" target="_blank">https://www.youtube.com/watch?v=xPRiuBd9Co0</a></p></div>
  <hr style="background-color: #c0c0c0">	
  
  <div id="aa4" style="cursor:pointer">
<h3>Display the Lock that matches your secret Key</h3>
</div>
<div id="a4" class="texter">
<p>1. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Click the <strong>Make Lock</strong> button. The lock matching that Key will appear
  in the main box, ready to be emailed or sent by texting. It is okay to strip the tags up to the "=" sign, or insert
  spaces, carriage returns, or special characters other than = + or / but
  not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking.</p>
<p>3. If you click <strong>Make Lock</strong> a second time, the general Lock directory screen will open with the lower box filled with the Lock you just made. If you supply your email, you'll be able to use the buttons on that screen to post it to the directory or check that it has not changed.</p>
  <p>Most of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=xPRiuBd9Co0" target="_blank">https://www.youtube.com/watch?v=xPRiuBd9Co0</a></p></div>
  <hr style="background-color: #c0c0c0">
      
  <div id="aa5" style="cursor:pointer">
<h3>Lock a message with a Lock, to be unlocked with the matching
  Key, without signing it (anonymous mode)</h3>
</div>
  <div id="a5" class="texter">
 <p>1. Make sure the <strong>Anon.</strong> mode radio button, located right below the main box, is selected.</p>
 <p>2. Fetch the recipient's Lock, and paste it into the large box that is accessed with the <strong>Locks</strong> button.  It is okay if the tags up to the "=" signs
   are missing, or extra spaces, carriage returns, or special characters
   other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by clicking the <strong>Locks</strong> button and then beginning to type the name associated with the Lock in the top box.</p>
 <p>3. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead of the Lock itself.</p>
<p>4. Write or paste your message in the main box. Click the <strong>Lck/Unl</strong> button. The
  locked message will appear in the main box, replacing the original message. Copy it and paste it into your
  communications program or click &#x25B6;, followed by Mail to open your default email. 
  It is okay to strip the tags up to the "=" sign, but not recommended. 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + / or % This message can only be unlocked by
  someone who has the Key matching the Lock used to lock it.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=0eYxeplsSx0" target="_blank">https://www.youtube.com/watch?v=0eYxeplsSx0</a></p></div>
  <hr style="background-color: #c0c0c0">	
  
  <div id="aa6" style="cursor:pointer">
<h3>Unlock an anonymous locked message (tags
  are PL**msa)</h3>
  </div>
  <div id="a6" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. If you didn't do it when PassLok opened, write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
<p>3. Paste the locked message into the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + / or % or is
  missing its tags. Then click the <strong>Lck/Unl</strong> button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
<p>4. Unlocking may fail if you have changed your Key recently and your locally stored Lock has not been updated. In that case, click the <strong>Reset</strong> button in the Locks screen to delete your stored Lock and try again.</p>
<p>Most of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=0eYxeplsSx0" target="_blank">https://www.youtube.com/watch?v=0eYxeplsSx0</a></p></div>
  <hr style="background-color: #c0c0c0">	

  <div id="aa7" style="cursor:pointer">
<h3>Lock a message with a Lock, to be unlocked with the matching
          Key, and sign it with your secret Key (signed mode)</h3>
  </div>
  <div id="a7" class="texter">
        <p>1. Make sure the <strong>Signed</strong> mode radio button, located right below the main box, is selected.</p>
        <p>2. If you didn't do it when PassLok opened, write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
        <p>3. Fetch the recipient's Lock, and paste it into the large box that is accessed with the <strong>Locks</strong> button.  It is okay if the tags up to the "=" signs
          are missing, or extra spaces, carriage returns, or special characters
          other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by clicking the <strong>Locks</strong> button and then beginning to type the name associated with the Lock in the top box.</p>
        <p>4. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead of the Lock itself.</p>
        <p>5. Write or paste your message in the main box. Click the <strong>Lck/Unl</strong> button. The
          locked message will appear in the main box, replacing the original message. Copy it and paste it into your
          communications program or click &#x25B6;, followed by Mail to open your default email. 
          It is okay to strip the tags up to the "=" sign, but not recommended. 
          PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
          also okay to split the locked message with spaces, line returns, and
          punctuation other than = + / or % This message can only be unlocked by
          someone having the Key matching the Lock used to lock it. Additionally, they must have your Lock in order to verify that it comes from you.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=F6Ov4MSk2XA" target="_blank">https://www.youtube.com/watch?v=F6Ov4MSk2XA</a></p>
  </div>
  <hr style="background-color: #c0c0c0"/>
  
  <div id="aa8" style="cursor:pointer">
<h3>Unlock a message  signed with the sender's Key (tags are PL**mss)</h3>
    </div>
  <div id="a8" class="texter">
      <p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
      <p>2. If you didn't do it when PassLok opened, write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
        if you want to display it, check the Show checkbox.</p>
      <p>3. Paste the sender's Lock in the large box of the Locks screen. If the Lock has been previously stored, you can retrieve it by typing the name associated with it in the small box at the top.      </p>
      <p>3. Paste the locked message in the main box. It is okay if it is broken up by
        spaces, carriage returns, and special characters other than = + / or % or is
        missing its tags. Then click the <strong>Lck/Unl</strong> button. The unlocked message
        will appear in the main box, replacing the locked message.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=F6Ov4MSk2XA" target="_blank">https://www.youtube.com/watch?v=F6Ov4MSk2XA</a></p>
</div>
      <hr style="background-color: #c0c0c0"/>

  <div id="aa9" style="cursor:pointer">
<h3>Lock a message so that nobody can read it after the exchange is over (PFS mode)</h3>
  </div>
  <div id="a9" class="texter">
        <p>1. Make sure the PFS mode radio button, located right below the main box, is selected.</p>
        <p>2. If you didn't do it when PassLok opened, write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
        <p>3. This mode requires the recipient's Lock or shared Key to be previously stored in the device's local directory. Follow the instructions from the Locks <strong>Help</strong> button to do this. Once the item is stored, you can retrieve it by beginning to type its name in the top box of the Locks screen. If you are restarting a PFS conversation that was interrupted, you must first clear the old PFS data for that recipient by clicking the <strong>Reset</strong> button after the recipient's name is displayed.</p>
        <p>4. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead of the Lock itself.</p>
        <p>5. Write or paste your message in the main box. Click the <strong>Lck/Unl</strong> button. The
          locked message will appear in the main box, replacing the original message. Copy it and paste it into your
          communications program or click &#x25B6;, followed by Mail to open your default email. 
          It is okay to strip the tags up to the "=" sign, but not recommended. 
          PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
          also okay to split the locked message with spaces, line returns, and
          punctuation other than = + / or % This message can only be unlocked by
          someone having the Key matching the Lock used to lock it.</p>
        <p>6. If Short mode is used, locking cannot be repeated without corrupting the PFS data stored in the device, which will make it impossible for the recipient to unlock the message (unless it is re-locked as a regular length message). Make sure your plain message is what you want before clicking <strong>Lck/Unl</strong>. This restriction does not apply to regular length messages, but you will get a warning alerting you if you are skipping a turn.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=oVJPJJuUCgQ" target="_blank">https://www.youtube.com/watch?v=oVJPJJuUCgQ</a></p>
  </div>
  <hr style="background-color: #c0c0c0"/>
  
  <div id="aa10" style="cursor:pointer">  
<h3>Unlock a message  that was locked in PFS mode (tags are PL**msp)</h3>
    </div>
  <div id="a10" class="texter">
      <p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
      <p>2. If you didn't do it when PassLok opened, write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
        if you want to display it, check the Show checkbox.</p>
      <p>3. This mode requires the recipient's Lock or shared Key to be previously stored in the device's local directory. Retrieve the item by typing the name associated with it in the small box at the top. The name must be displayed in full on the message above the box for PFS mode to work.</p>
      <p>4. Paste the locked message in the main box. It is okay if it is broken up by
        spaces, carriage returns, and special characters other than = + or / or is
        missing its tags. Then click the <strong>Lck/Unl</strong> button. The unlocked message
        will appear in the main box, replacing the locked message.</p>
      <p>5. If this was a Short mode message, it can be unlocked only once. Attempting to unlock it again will corrupt the PFS data stored in the device, which is needed to keep the conversation going.  This restriction does not apply to regular length messages, but you will get a warning alerting you that a turn was skipped.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=oVJPJJuUCgQ" target="_blank">https://www.youtube.com/watch?v=oVJPJJuUCgQ</a></p>
  </div>
      <hr style="background-color: #c0c0c0"/>
      
  <div id="aa11" style="cursor:pointer">
<h3>Lock a message with a shared Key, to be unlocked with the same Key</h3>  
</div>
      <div id="a11" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since they do not apply to this mode.</p>
<p>2. Write or paste the shared Key in the large box that is accessed with the <strong>Locks</strong> button. If the shared Key was previously stored, you can search for it by typing in the top box the name associated with the Key. When you type "Enter", the stored Key is decrypted for you to see.  For a stored Key to function, your secret Key must have been  entered previously by clicking the <strong>myKey</strong> button.</p>
<p>3. To lock a message so it can be read by several people, place their respective shared Keys in the box, one per line. If a Key was previously stored, you can write the name associated with that Key, instead. You can mix shared Keys and Locks.</p>
<p>4. Write or paste the message in the main box. Click the <strong>Lck/Unl</strong> button. The
  locked message will appear in the main box, replacing the original text. Copy it and paste it into your
  communications program or click &#x25B6;, and then <strong>Mail</strong> to open your default email program. 
  It is okay to strip the tags up to the "=" sign, but not recommended; 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + / or % This message can only be unlocked by
  someone having the same shared Key.</p>
<p>5. The tags will depend on the type of locking selected for using Locks. There is no special tag to indicate that a shared Key was used instead of a Lock.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=zFbsTwdHRYQ" target="_blank">https://www.youtube.com/watch?v=zFbsTwdHRYQ</a></p></div>
  <hr style="background-color: #c0c0c0">	
  
  <div id="aa12" style="cursor:pointer">
 <h3>Unlock a message locked with a shared Key</h3>
</div>
      <div id="a12" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. Write or paste the shared Key in the large box that is accessed with the <strong>Locks</strong> button. If the Key was previously stored, you can search for it by typing in the top box the name associated with the Key. When you type "Enter", the stored Key is decrypted for you to see. For a stored Key to function, your secret Key must have been entered previously by clicking the <strong>myKey</strong> button.</p>
<p>3. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + / or % or is
  missing its tags. Then click the <strong>Lck/Unl</strong> button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=zFbsTwdHRYQ" target="_blank">https://www.youtube.com/watch?v=zFbsTwdHRYQ</a></p></div>
  <hr style="background-color: #c0c0c0">	
   
    <div id="aa13" style="cursor:pointer">     
    <h3>Make a short locked message suitable for texting</h3>
</div>
<div id="a13" class="texter">
<p>1. Check the <strong>Short</strong> checkbox below the main box. Also make sure the appropriate locking mode is selected with the radio buttons. The radio buttons don't matter if the message is being locked with a shared Key.</p>
<p>2. Write or paste your message into the main box. Message length is limited to 58
  ASCII characters when locking with a shared Key or in signed mode, 38 in anonymous mode, 37 in PFS mode. Non-ASCII characters use 6 spaces each, so avoid them if
  you can. Any text beyond the limit will be lost. A message above the main box will tell you how much space is left, depending on the locking mode selected. Click the <strong>Lck/Unl</strong> button.</p>
<p>3. The locked message will appear in the main box, replacing the original message. Copy it and paste it into your communications program. The locked
  message, which has no tags, will fit within one SMS message (160
  characters).</p>
<p>4. On a mobile device, the locked message will be selected and ready to be copied into the clipboard. <strong>You need to copy it</strong> manually before clicking the <strong>Txt/Img</strong> button, which will open your texting app.</p>
<p>5. Short mode is not available for multiple recipients.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=Ly9ESisRKE8" target="_blank">https://www.youtube.com/watch?v=Ly9ESisRKE8</a></p></div>
  <hr style="background-color: #c0c0c0">	
  
  <div id="aa14" style="cursor:pointer">
<h3>Unlock a short locked message (no tags)</h3>
  </div>
  <div id="a14" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, or whether the Short checkbox is checked, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. Paste the locked message into the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters. As with regular-length messages, either a shared Key must be entered in the <strong>Locks</strong> box, or your secret Key in its own box, prior to unlocking. 
  Then click the <strong>Lck/Unl</strong> button.</p>
<p>3. The unlocked message will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=Ly9ESisRKE8" target="_blank">https://www.youtube.com/watch?v=Ly9ESisRKE8</a></p></div>
  <hr style="background-color: #c0c0c0">	 
  
  <div id="aa15" style="cursor:pointer">
<h3>Sign a text with your secret Key</h3>
</div>
<div id="a15" class="texter">
<p>1. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so if you want to display it, check the Show checkbox.</p>
<p>2. Write or paste the text to be signed in the main box. Click the <strong>Sig/Ver</strong>
  button (abbreviated from Sign/Verify). A signature matching the text and your Key will be appended at the end of the text in the main box. Copy
  it and use it as appropriate. If you click &#x25B6; followed by Mail the text with its signature
  will be placed into an email using the default program.
  It is okay to strip the tags up to the "="
  sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. 
  It is also okay to split the signature with spaces,
  and punctuation other than line returns or = + or /. </p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=YiiwcOmbI2U" target="_blank">https://www.youtube.com/watch?v=YiiwcOmbI2U</a></p></div>
  <hr style="background-color: #c0c0c0">  
  
  <div id="aa16" style="cursor:pointer">
<h3>Verify a signature attached to a text (signature tags are PL**sig) </h3>
</div>
<div id="a16" class="texter">
<p>1. Paste the Lock belonging to the person who added the signature into the large box that is accessed with the <strong>Locks</strong> button. It is okay
  if the tags up to the "=" signs are missing, or extra spaces, carriage
  returns, or special characters other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by  beginning to type the name associated with the Lock in the top box.</p>
<p>2. Write or paste the text with its signature appended on a separate line at the end, in the main box. It is okay if 
  the signature is broken up by spaces and special characters other than = + or / or is missing
  its tags up to the "=", but it should not be broken by carriage returns.
  Then click the <strong>Sig/Ver</strong> button. A message above the main box will say whether
  or not the signature for that text has been verified.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=YiiwcOmbI2U" target="_blank">https://www.youtube.com/watch?v=YiiwcOmbI2U</a></p></div>
    <hr style="background-color: #c0c0c0">
  
  <div id="aa17" style="cursor:pointer">
<h3>Lock a second, undetectable message in addition to the main message
  (Decoy mode)</h3>
  </div>
  <div id="a17" class="texter">
<p>1. Check the <strong>Decoy</strong> mode checkbox below the main box.</p>
<p>2. Follow the above instructions for any kind of locking, using
  the recipient's Lock or a shared Key, short or regular length, including PFS mode. This also works when adding a signature. If Decoy mode is checked, a popup will ask for a Decoy Password to lock the hidden message, and the hidden message itself.</p>
<p>3. Write or paste into the the corresponding boxes the Decoy Password and the hidden message. The length of the hidden message is limited to
  152 ASCII characters in key-locked and signed modes, 87 characters in
  anonymous and PFS modes, 37 characters in short message mode (key-locked or signed only), 40 characters in signatures. Non-ASCII characters
  use 6 spaces each, so avoid them if you can. Any text beyond the limit will be lost. Then click <strong>OK</strong>. To view the Password before you use it, check the Show checkbox.</p>
<p>4. After clicking <strong>OK</strong>, the locked
  message containing both the main text and the hidden text will appear in
  the main box, replacing the original text. If it is a signature, it will be appended to the text. Copy it and paste it into your
  communications program. As with regular locked messages, it is okay to
  strip the tags up to the "=" sign, but not recommended. It is also okay to
  split the locked message with spaces, line returns, and punctuation other
  than = + / or %</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WaXQGYP0Sec" target="_blank">https://www.youtube.com/watch?v=WaXQGYP0Sec</a></p></div>
  <hr style="background-color: #c0c0c0">	
  
  <div id="aa18" style="cursor:pointer">
<h3>Reveal the hidden text contained within a message locked in Decoy
  mode</h3>
  </div>
  <div id="a18" class="texter">
<p>1. Check the <strong>Decoy</strong> mode checkbox below the main box.</p>
<p>2. Follow the instructions for any of the unlocking modes, using a
  secret or shared Key, or for verifying a signature. If Decoy mode is
  checked, a popup will ask for a Decoy Password.</p>
<p>3. Write or paste into the popup box the Decoy Password for the hidden
  message and click <strong>OK</strong>. To view the Password before you use it, check the Show checkbox. The hidden message, if it exists,
  will appear above the main box. In the case of signatures, the hidden message appears in the place normally used by the verification message, so if you still wish to verify the signature, you need to uncheck <strong>Decoy</strong> mode and click <strong>Sig/Ver</strong> again so the verification message is displayed.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WaXQGYP0Sec" target="_blank">https://www.youtube.com/watch?v=WaXQGYP0Sec</a></p></div>
  <hr style="background-color: #c0c0c0">
  
	<div id="aa19" style="cursor:pointer">  
  <h3>I have an item that was locked/signed with a previous version of PassLok, and the current version cannot handle it</h3>
 </div>
  <div id="a19" class="texter">
    <p>We do not recommend using old versions for new work. Newer versions have enhanced security and are more user-friendly. But sometimes you may need to handle an item that is incompatible with the current version. Here is a pretty complete list of PassLok versions, with links to them.
    <p><strong>Current version</strong> of PassLok is: <strong>1.7.05</strong></p>
<p>made on: 3/28/14</p>
<p>source server: <a href="https://passlok.com" target="_blank">https://passlok.com</a></p>
<p>information page: <a href="http://passlok.weebly.com" target="_blank">http://passlok.weebly.com</a></p>
<p>GitHub page: <a href="https://github.com/fruiz500/passlok">https://github.com/fruiz500/passlok</a></p>
<p>mirrors:</p>
<p><a href="https://www.autistici.org/passlok">https://www.autistici.org/passlok</a> (non-US, self-certified)</p>
<p><a href="https://passlok.site44.com">https://passlok.site44.com</a></p>
<p><a href="https://fruiz500.github.io/passlok" target="_blank">https://fruiz500.github.io/passlok</a></p>
<p>SHA256 for this version and video of the author reading it at:</p>
<p><a href="http://passlok.weebly.com/get-passlok.html" target="_blank">http://passlok.weebly.com/get-passlok.html</a></p>
<p>&nbsp;</p>
<p><strong>Previous versions:</strong></p>
<p><strong>1.6.02</strong> (2c64-63d5-5d68-c7b2-9350-68cc-8bef-1a75-ddc1-1fa0-cd04-4428-f3ef-c079-e14f-4133)</p>
<p><a href="https://passlok.com/archive/passlok16.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok16.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok16.html" target="_blank">Site44</a></p>
<p><a href="https://www.youtube.com/watch?v=Z5e9TVGMMsE" target="_blank">Author reading the ID</a></p>
<p><strong>1.5.03</strong>  (0061-4b79-8ba1-8fee-34c5-e243-96e9-4c7c-a0ea-cfc5-82c1-a44d-4cbb-06c4-ca00-985c)</p>
<p><a href="https://passlok.com/archive/passlok15.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok15.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok15.html" target="_blank">Site44</a></p>
<p><a href="https://www.youtube.com/watch?v=YQIDRKE_wbI" target="_blank">Author reading the ID</a></p>
<p>The following (except 1.0) were edited so the archived help file works, changing the ID from the original (therefore no video)</p>
<p><strong>1.4.03</strong> (f1cc-8931-1d31-4d65-4dfe-fb0d-5368-f854-3766-b240-f131-c93f-a0e9-8d14-752e-018e)</p>
<p><a href="https://passlok.com/archive/passlok14.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok14.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok14.html" target="_blank">Site44</a></p>
<p><strong>1.3.03</strong> (7c6f-3d59-1059-e712-15ea-8dcf-dcde-861a-7359-6508-3b29-5720-41c9-8271-cb69-f01a)</p>
<p><a href="https://passlok.com/archive/passlok13.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok13.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok13.html" target="_blank">Site44</a></p>
<p><strong>1.2</strong> (c17b-c529-8757-578a-6bc2-bdc4-122e-c607-8c16-19ef-b9ee-8d4d-75aa-cf0a-b703-e0ec)</p>
<p><a href="https://passlok.com/archive/passlok12.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok12.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok12.html" target="_blank">Site44</a></p>
<p><strong>1.1</strong> (8e5c-9714-eec3-cc65-aa8f-640d-d434-2747-aa24-624c-74c5-65ea-4077-0f0f-3b22-cc30)</p>
<p><a href="https://passlok.com/archive/passlok11.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok11.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok11.html" target="_blank">Site44</a></p>
<p><strong>1.0</strong> (a907-25eb-50e3-e4a6-5f4b-27c1-684e-f590-6094-6fae-52f3-c7ca-47b1-732c-9eab-3e9b)</p>
<p><a href="https://passlok.com/archive/passlok10.html" target="_blank">PassLok.com</a></p>
<p><a href="https://www.autistici.org/passlok/archive/passlok10.html" target="_blank">Autistici</a></p>
<p><a href="https://passlok.site44.com/archive/passlok10.html" target="_blank">Site44</a></p>
  </div>
   <hr style="background-color: #c0c0c0">
   
     <div id="aa20" style="cursor:pointer">  
  <h3>I want to know PassLok in depth. Is there more information?</h3>
 </div>
  <div id="a20" class="texter">
    <p>You can start by looking at the help pages that open from the Locks screen (about Locks and Keys) and after clicking the &#x25B6; button (about disguising the output, files, and other neat tricks other than locking/unlocking). If this is not enough for you, here are a couple more sources you may want to check out:</p>
    <p>The PassLok <a href="http://passlok.weebly.com/uploads/2/4/1/8/24187628/passlok_manual17.pdf" target="_blank">manual in PDF form.</a></p>
    <p>The PassLok informational website at <a href="http://passlok.weebly.com" target="_blank">http://passlok.weebly.com</a>. It contains a number of videos and more PDF documents.</p>
  </div>
   <hr style="background-color: #c0c0c0">
   
   <div id="aa21" style="cursor:pointer">  
  <h3>None of the help items answers my question / I want to give feedback</h3>
 </div>
  <div id="a21" class="texter">
    <p>Then you can send us an email at <a href="mailto:passlokprivacy@gmail.com?subject=PassLok support request" target="_blank">passlokprivacy@gmail.com</a> (the link will open your email client). We'll do our best to reply in a timely fashion.</p>
    <p>If you want to lock it with PassLok, here is our Lock. Clicking on it will add it to your local directory under name "PassLok support":</p>
    <p><span id='support' style="color:blue">PL17lok=SCh77O0wzIgKuNjct+vV7RJifPi18r5zJUfPonx5WbnrnJ9iPaypXYT+NCp1RrVKykIOTe7Jg5pa2UW5FipUWwN=PL17lok</span></p>
    <p>Good constructive feedback is hard to get, so let us <strong>thank you</strong> right now, before we read your email.</p>
  </div>
   <hr style="background-color: #c0c0c0">
     
   <div id="aa22" style="cursor:pointer">
<h3>Privacy Statement</h3>
</div>
<div id="a22" class="texter">
<p>PassLok provides excellent security, since it is a self-contained piece of code that does not rely on servers for its functionality. Therefore:</p>
<p><strong>1. We'll never give your secret Key to anyone.</strong> We cannot do anything concerning your secret Key because we just don't have it. PassLok is designed so your secret Key never leaves your device. It is never stored, either, and it gets deleted from memory after five minutes of not being used.</p>
<p><strong>2. We'll never knowingly give you or anyone else a conterfeit Lock made from any Key</strong>. PassLok has functions to help you to authenticate Locks, but it is still your responsibility to do so. Locks posted on the general Lock directory are verified only by email, which is not very secure, so beware if you use a Lock that you got from the general directory.</p>
<p><strong>3. We'll never weaken the cryptography methods contained within PassLok at the request of a third party, private or public.</strong> This also means no backdoors will ever be added. We'd rather shut down PassLok than be forced to do this, which would betray the very essence of PassLok. If we learn that counterfeit copies are circulating (whether placed by hackers or government agencies), we'll make the fact known to users.</p>
<p>Since PassLok, like every html file, is a piece of human-readable writing, we consider it an expression of free speech protected by the laws of many countries. Putting into circulation tampered versions of it violates free speech and copyright protection laws.</p>
<p>PassLok contains strong cryptographic methods, which may be illegal to use in some countries. Please check the local laws before using PassLok.</p>
</div>
<hr style="background-color: #c0c0c0">

	<address>
	PassLok v1.7.07 &#169; F. Ruiz 2014
	</address>
    <ul>
	<li>
	engine: SJCL by Stark, Hamburg, and Boneh 2012
	</li>
    <li>
    Lock server by W. Huang 2014
    </li>
    <li>
    text hide trick by S. Gangadharan 2005
    </li>
	<li>
    password strength meter by D. Karr 2007
    </li>
	<li>
    Shamir secret sharing by A. Stetsyuk 2013
    </li>
	<li>
    image hiding: PixelJihad by Zach Oakes 2012
    </li>
    <li>
    file In/Out based on an article from the This Could Be Better blog. 2012</li>
    <li>sjcl-scrypt key stretching implementation by joe-invincible 2013</li>
    </ul>
    <address>This document may be used, modified or redistributed under GNU GPL license, version 3.0 or higher.</address> 

	<hr style="background-color: #c0c0c0"> 
    
  <button class="cssbutton" id="closemainhelpButton2" value="< Back" >&#x25C0; Back</button>
</div>

<div id="lockhelp" class="texter" style="display: none;">
	<button class="cssbutton" id="closelockhelpButton" value="< Back" >&#x25C0; Back</button>
    <hr style="background-color: #c0c0c0">
    
  <div id="bb1" style="cursor:pointer">  
<h3>Add an item (shared Key, Lock, etc.) to PassLok's local directory</h3>
  </div>
    <div id="b1" class="texter">
      <p>1. You must have entered your secret Key for any items to be stored. You enter this Key by means of the <strong>myKey</strong> button on the main screen.</p>
      <p>2. Write a name for the item in the little box on top. If the name is already taken, something will appear in the large box below it; if you use that name, the stored item will be replaced rather than added.</p>
      <p>3. Write or paste the item in the large box. It can be anything: somebody's Lock, a shared Key, a cover text, a list. Don't write your secret Key here; its proper place is the dialog that opens with the <strong>myKey</strong> button. Then click the <strong>Save</strong> button.</p>
      <p>4. If you write nothing in the large box before clicking the <strong>Save</strong> button, PassLok will generate a 86-character base64 string, which will be stored under the name supplied in the small box. This way you can use PassLok to make secure passwords for websites, etc.</p>
      <p>5. A message confirms that the item has been added, and the item appears in the lower box encrypted with your secret Key, which is the way it is stored.</p>
      <p>6. (<em>Chrome app only</em>) The item will also be added to the Chrome sync area, so it is available on a different computer after you log into Chrome.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=FDNRK4CdW2o" target="_blank">https://www.youtube.com/watch?v=FDNRK4CdW2o</a></p>
    </div>
    <hr style="background-color: #c0c0c0">
   
 <div id="bb2" style="cursor:pointer">
<h3>Retrieve an item from the local directory</h3>
  </div>
      <div id="b2" class="texter">
       <p>1. You must have entered your secret Key for any stored items to be really retrieved, since they are always stored encrypted. You enter this Key by means of the <strong>myKey</strong> button on the main screen.</p>
       <p>2. Start writing the name of the item in the small box. As you type, the line above the box displays existing items whose names match what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you're looking for. Search is case-insensitive, so if the item does not appear, that probably means the name is wrong.       </p>
       <p>3. PassLok can use the item in encrypted form, but if you want to see the original, you can type "Enter" after the correct name is displayed, and the item will be decrypted if the correct secret Key has been entered. The item is also decrypted when you click the <strong>Back</strong> button. If the item is a cover text, it loads automatically as new cover text.</p>
       <p>4. (<em>Chrome app only</em>) If you type &quot;Enter&quot; after a name that was not found on the local database, PassLok will look for it in its Chrome sync area, which syncs across computers, and then adds it to the local directory.</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=FDNRK4CdW2o" target="_blank">https://www.youtube.com/watch?v=FDNRK4CdW2o</a></p>
       </div>
     <hr style="background-color: #c0c0c0"/>
       
<div id="bb3" style="cursor:pointer">
 <h3>Delete a stored item</h3>
 </div>
  <div id="b3" class="texter">
       <p>1. Start writing the name of the item in the small box. As you type, the line above the box displays existing items matching what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you are looking for. Search is case-insensitive, so if the item does not appear, that probably means the name is wrong.</p>
       <p>2. Click the <strong>Del</strong> button. A message confirms that the item has been deleted from the local directory.</p>
       <p>3. (<em>Chrome app only</em>) If the Chrome sync area is accessible from the computer, the item will also be deleted from there, after a confirmation popup.</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=_rR_ZQZ932c" target="_blank">https://www.youtube.com/watch?v=_rR_ZQZ932c</a></p>
       </div>
  <hr style="background-color: #c0c0c0"/>
        
 <div id="bb4" style="cursor:pointer">
 <h3>Reset the hidden information pertaining to an item (PFS, etc.)</h3>
 </div>
  <div id="b4" class="texter">
          <p>1. Start writing the name of the item in the small box. As you type, the line above the box displays existing items matching what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you're looking for. Search is case-insensitive, so if the item does not appear, that probably means that the name is wrong.</p>
          <p>2. Click the <strong>Reset</strong> button. A message confirms that the PFS data for the item has been deleted. You must reset the data pertaining to the other party whenever a PFS conversation has gone out of sync so the PFS process can be restarted.</p>
          <p>3. If you click the <strong>Reset</strong> button with nothing displayed on either box, the copy of your own Lock cached within PassLok will be erased. This is useful if you have changed your secret Key.</p>
          <p>Most of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=_rR_ZQZ932c" target="_blank">https://www.youtube.com/watch?v=_rR_ZQZ932c</a></p>
  </div>
  <hr style="background-color: #c0c0c0"/>
  
<div id="bb5" style="cursor:pointer">
      <h3>Find a Lock in PassLok's general directory</h3>
  </div>
  <div id="b5" class="texter">
        <p>Sometimes you may need somebody's Lock and not have it stored in your local directory or anywhere else. This is where PassLok's general directory comes in. When you click the <strong>Lock directory</strong> button, a new screen opens up where you can search for a Lock, watch the authenticating video belonging to a Lock, or upload your own Lock. The Locks in this directory are indexed by email address.</p>
        <p>The Lock directory has its own set of help pages, but here some important things:</p>
        <p>a. The Lock directory is a separate webpage from PassLok, which is indicated by a different color scheme. Normally, you will need to copy and paste material between it and PassLok, but if you have found a Lock it gets copied automatically to the Locks screen so the only thing you may need to do is give it a name and save it.</p>
        <p>b. PassLok makes no guarantee as to the authenticity of the Locks contained in its general directory. Email confirmation is required to load or update Locks, but this is not very secure. Since users are encouraged to add authenticating videos and the directory screen has a button especially designed to play them, you should watch the video attached to a Lock before you use it for anything sensitive.</p>
        <p>c. The PassLok general directory is meant as a convenience, not as a replacement for your local directory. The general directory is not available when you are offline (the local one is). You cannot upload anything but Locks to the general directory.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=1UQw7MaK3T8" target="_blank">https://www.youtube.com/watch?v=1UQw7MaK3T8</a></p>      
  </div>
  <hr style="background-color: #c0c0c0"/>
       
 <div id="bb6" style="cursor:pointer">
      <h3>Display the entire local directory</h3>
  </div>
  <div id="b6" class="texter">
        <p>1. Click the <strong>All</strong> button below the big box. The complete local directory, including PFS and hidden data, is displayed in the box so you can find items and copy them easily.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
        </div>
  <hr style="background-color: #c0c0c0"/>
           
  <div id="bb7" style="cursor:pointer">
  <h3>Move the entire local directory</h3>
       </div>
 <div id="b7" class="texter">
      <p>1. Click the <strong>Move</strong> button below the big box. The entire directory is first locked with the secret Key, and then placed in the main box. Then a prompt asks you to confirm deleting it from the device. If you click <strong>OK,</strong> the entire local directory is deleted. There is no going back. If you click <strong>Cancel</strong>, the locked backup remains in the main box. This is useful whenever you stop using a device or just want to transfer it to another device, or if the directory becomes corrupted.</p>
      <p>2. To retrieve a backed-up directory (has PL**dir tags), place it in the main box and click <strong>Lck/Unl</strong>. If the secret Key has been entered, the database will be unlocked and placed in the Locks screen. Then you can add it to the device's current directory by clicking <strong>Merge</strong>.</p>
      <p>3. (<em>Chrome app only</em>) Even if the local directory is completely deleted, the items in your Chrome sync area remain available.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
  </div>
 <hr style="background-color: #c0c0c0"/>

 <div id="bb8" style="cursor:pointer">
       <h3>Merge additional data into the local directory</h3>
  </div>
  <div id="b8" class="texter">
       <p>1. Paste the additional data into the big box. The format is the following: name, followed by a colon (:), new line, item data; then two new lines before the next name, and so forth. If a name also has hidden data and PFS data, those follow the item data, occupying consecutive lines.</p>
       <p>2. Click the <strong>Merge</strong> button. The new data is merged into the local directory. Items are added in encrypted form but are not checked as they are added, so it is possible that different items may need different Keys to be decrypted, if you changed your secret Key in the past.</p>
       <p>3. (<em>Chrome app only</em>) If the Chrome sync area is accessible from the computer, the additional data will also be added to that area, so it is accessible from other computers.</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
  </div>
  <hr style="background-color: #c0c0c0"/>
                     
 <div id="bb9" style="cursor:pointer">
     <h3>Make a List of items</h3>
 </div>
  <div id="b9" class="texter">
      <p>1. You can always make a List of Locks and shared Keys, in order to lock a message for multiple recipients, by writing the Locks or shared Keys in separate lines of the Locks box. PassLok will remember it during the current session if you click the <strong>List</strong> button. Adding one or several items is as easy as putting them in the box and clicking<strong> List</strong> again. If you click <strong>List</strong> with the box empty, the current List is displayed.The current List is deleted by pressing the <strong>Reset</strong> button while the List is displayed.</p>
      <p>2. If you want to store a List permanently, you must write a name for it in the small box, then write the items or re-display them by clicking the<strong> List</strong> button, and then click <strong>Save</strong>. You must have entered your secret Key before the List can be saved.</p>
      <p>3.You can also make a List of items already stored in the local directory, which can be itself stored. To do this, write the name of the item rather than the item itself. If you don't recall the exact name of an item, start typing it in the upper box, and click <strong>List</strong> when the correct item appears in the space above the box. The item name will be added to the current List.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=sO-g9x2RAV8" target="_blank">https://www.youtube.com/watch?v=sO-g9x2RAV8</a></p>
      </div>              
     <hr style="background-color: #c0c0c0">
     
  <div id="bb10" style="cursor:pointer">
  <h3>Make a random Key</h3>
  </div>
 <div id="b10" class="texter">
      <p>Sometimes you want to make a high-security random Key, which can be used as a shared Key or even as a secret Key. It might be split into several parts for safekeeping, as described in another help screen, or stored in encrypted form rather than memorized. PassLok has a way to make a 86-character random Key:      </p>
      <p>1. Click <strong>Locks</strong>, and write a name in the small name box if you want to save the random Key. If the name is not in the local directory, the lower box will end up empty.</p>
      <p>2. Then, with the lower box empty, click <strong>Save</strong>. An 86-character random Key is made, which is immediately encrypted with the secret Key, if it has been previously entered. From then on this random Key, suitable as a shared Key or high-security password, can be recalled by typing its name into the small box. If no name is supplied in the small box before clicking the <strong>Save</strong> button, the Key is still generated but it is not saved to the local directory.</p>
      <p>3.To make the Lock matching this random string as a Key, copy the string, go back to the main screen, click <strong>myKey</strong>, paste the string there, and click <strong>Make Lock</strong>. The Lock will appear in the main screen.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=9gRE1xPr_nE" target="_blank">https://www.youtube.com/watch?v=9gRE1xPr_nE</a></p>
  </div>
 <hr style="background-color: #c0c0c0"/>
 
   <div id="bb11" style="cursor:pointer">
  <h3>Combine a Key and a Lock</h3>
  </div>
 <div id="b11" class="texter">
      <p>This operation, which goes by the technical name of "Diffie-Hellman key exchange," combines a Key and a Lock. It is at the core of many PassLok functions. Should you ever want to compute the result manually, here is how to do it:</p>
      <p>1. Write or paste the Key or the Lock in the main box.</p>
      <p>2. Click <strong>Locks</strong>, and then write or paste the other item in the lower box. If the item is in PassLok's local directory, you can bring it out by starting to type its name in the upper box.</p>
      <p>3. Click the <strong>Merge</strong> button. The Key and the Lock will merge and the 86-character result is placed in both the Locks and the main screens. If both items or neither of them is a valid Lock, the merging process fails and a message is displayed.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=L0UC61Z2KAA" target="_blank">https://www.youtube.com/watch?v=L0UC61Z2KAA</a></p>
  </div>
 <hr style="background-color: #c0c0c0"/>
 
   <div id="bb12" style="cursor:pointer">
  <h3>Make a video to authenticate your Lock</h3>
  </div>
 <div id="b12" class="texter">
      <p>It is highly recommended that you make a video whenever you change your secret Key, so that others can be assured that the matching Lock really belongs you. PassLok does not have video functions, but here are a few short instructions on how to do this, using a popular online video resource:</p>
      <p>1. If the ID is not displayed above the main box when your Lock is in the box, add a space or any other character to the end, so it is displayed. This should not affect the ID. Copy this ID.</p>
      <p>2. Go to a device with a camera and make a video of yourself reading this ID or a substantial portion of it (say, the first four groups of four characters). For better security, have some music playing in the background as you read the ID. You may also want to show to the camera a piece of paper where you've written the ID. The video should be about one minute long. Then post the video on a public online service.</p>
      <p>3. Alternatively, you may want to read the code (between the PL**lok tags) of the Lock itself, or a significant portion of it (say, the first twelve characters), in which case you can skip step 1. Bear in mind that some characters are capital letters and some are lowercase, and those are not interchangeable</p>
      <p>3. When you post your Lock so that people can use it to lock messages for you, post also the address of the video on the line immediately below the Lock, to facilitate the verifying process in step 4. If you post it this way on the PassLok general directory (accessed by the <strong>Lock directory</strong> button), users will be able to watch the video by just clicking the <strong>Play</strong> button.</p>
      <p>4. People wishing to authenticate your Lock will generate the ID as in step 1 (which won't be affected by having the video address on the line below), and then if they click the <strong>Save</strong> button at the bottom of the screen the accompanying video will start playing on a separate browser tab. Then they will be able to compare it with the ID they see you reading on the video. If they know your face and your voice, they will be assured that the Lock is authentic.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=bODBEB6Oo2I" target="_blank">https://www.youtube.com/watch?v=bODBEB6Oo2I</a></p>
 </div>
 <hr style="background-color: #c0c0c0"/>
 
   <div id="bb13" style="cursor:pointer">
  <h3>Authenticate a Lock without using videos</h3>
  </div>
 <div id="b13" class="texter">
      <p>The easy way: get the ID of the Lock by placing it in the main box and clicking &#x25B6;. The ID will be displayed at the top. Then you can call the Lock's owner and ask him/her to read the same ID over the phone, or even a substantial portion of the code inside the Lock proper. But let's say you cannot establish a live conversation. If you are communicating exclusively by email, you can send a person whom you know and who knows you the following message, or something like it:</p>
      <p><br />
        <em>Dear So-and-So:</em><br />
        <em>I just obtained your PassLok Lock from (cite source), but I still wonder if it is authentic since I am unable to view the authenticating video. Therefore, I ask you to help me authenticate it through the interlock protocol. Here's what I want you to do:</em></p>
      <ol>
        <li><em>Write me a message asking me to take a picture or video of myself doing something of your choice. Lock the message with my Lock, which is at the bottom of this message, but don't send it back to me just yet. Instead, save it and display the locked message's ID, and send me that.</em></li>
        <li><em>When I receive your ID, I will also write a message asking you to do something in a picture or short video. I'll lock that message with your Lock, but I'll send you the ID of the locked message first. When you get it, go ahead and send me the locked message containing your instructions.</em></li>
        <li><em>When I get that, I'll check that the ID you sent me earlier matches the locked message, and then I'll follow your instructions. I'll send you the picture or video right away, unlocked, along with my locked request. Expect to receive it within half an hour of your message.</em></li>
        <li><em>When you get it, please make sure its ID matches the ID I sent you earlier, and that what I sent conforms to your instructions. If everything is okay, go ahead and follow my instructions and send me the result as soon as possible, unlocked as well, within half an hour if you can. Then I'll know that your Lock is authentic.</em></li>
    </ol>
      <p><em>Many thanks. Sincerely, This-and-That</em></p>
    <p><br />
      Alternatively, you can ask the other person to split the locked message in two, and send you first one half, then the other half (PassLok has a built-in function to split messages securely, explained in another help screen).  The pictures or videos (or recordings) don't need to be locked. Only the instructions for making them need to be locked and transmitted with a two-step process. There is an article in PassLok.com that explains how this protocol works for authenticating Locks.</p>
  </div>

	<hr style="background-color: #c0c0c0">
  
  <button class="cssbutton" id="closelockhelpButton2" value="< Back" >&#x25C0; Back</button>
</div>

<div id="extrahelp" class="texter" style="display: none;">
	<button class="cssbutton" id="closeextrahelpButton" value="< Back" >&#x25C0; Back</button>
	<hr style="background-color: #c0c0c0">
     
  <div id="cc1" style="cursor:pointer">
<h3>Send a PassLok item (Lock, message, etc.) by email</h3>
  </div>
  <div id="c1" class="texter">  
<p>1. Check that the item is in the main box.</p>
<p>2. Click the &#x25B6; button in order to reveal the button dealing with email, which is above the text box.</p>
<p>3. Click the <strong>Mail</strong> button. If so configured in the device, a window appears containing the item and some explanatory text. You only need to supply the recipient's email address and a subject line before clicking the Send button. If you do not want any explanatory text, check the No tags checkbox in the main screen before clicking &#x25B6;.</p>
<p>4. This only works for sending messages, not for receiving them. If you receive a PassLok-locked message, you must copy it into the clipboard and then paste it into the main screen of PassLok, so it can be unlocked. Be also aware that webmail services, such as Gmail, limit the length of messages that can be composed this way. If you get an error from the mail host, you can always copy the box and paste it into a normal mail compose screen.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2zxCkA4rDN8" target="_blank">https://www.youtube.com/watch?v=2zxCkA4rDN8</a></p>
</div>
  <hr style="background-color: #c0c0c0">
  
  <div id="cc2" style="cursor:pointer">
<h3>Send a PassLok item by Text messaging (mobile only)</h3>
  </div>
  <div id="c2" class="texter">  
<p>1. Check that the item to be sent is in the main box.</p>
<p>2. Click the &#x25B6; button in order to reveal the button dealing with text messaging, which is labeled Txt/Img.</p>
<p>3. Click the <strong>Select</strong> button so the text can be selected.</p>
<p>4. Then click the Copy label as it appears on screen. The item is copied to clipboard.</p>
<p>5. Now you can click the <strong>Txt/Img</strong> button. A window appears with the default texting app.</p>
<p>6. Touch the input box and then paste the clipboard. Send the message in the usual way.</p>
<p>7. To unlock a locked message received by texting, you must copy it to the clipboard, and then paste it in the main box of PassLok.</p>
<p>If you use Short mode to lock a message, steps 2 and 3 are automatic.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2zxCkA4rDN8" target="_blank">https://www.youtube.com/watch?v=2zxCkA4rDN8</a></p>
</div>
<hr style="background-color: #c0c0c0"/>

<div id="cc3" style="cursor:pointer">
  <h3>Split an item into several random-looking parts</h3>
</div>
<div id="c3" class="texter">
  <p>1. Put the item in the box on the main screen, and then click the &#x25B6; button.</p>
  <p>2. The item should remain in the box as the buttons around it change. Then click the <strong>Splt/Jn</strong> button.</p>
  <p>3. A popup asks for the total number of parts to be made, and the minimum number required to retrieve the original. Write those numbers, which must be between 2 and 255, and click <strong>OK</strong>. The parts appear in the main box, replacing the original item, and a message confirms it. Copy the parts one by one and send/store them as needed. It is okay to strip the tags up to the "=" sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is also okay to split the parts with spaces and punctuation other than = + / or line returns.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=3-6CNa6iNKc" target="_blank">https://www.youtube.com/watch?v=3-6CNa6iNKc</a></p>
</div>
<hr style="background-color: #c0c0c0"/>

<div id="cc4" style="cursor:pointer">
  <h3>Join parts to retrieve the original item (tags are PL**p***)</h3>
</div>
<div id="c4" class="texter">
  <p>1. Paste a sufficient number of parts on separate lines of the main box. Make sure that each part is unique. You need as many parts as the second number entered when the item was split, which is written at the end of each PL**p tag. Having more parts than the minimum is okay, so long as they belong to the same set and are not corrupt. They don't need to be placed in any particular order.</p>
  <p>2. Click the &#x25B6; button, and then the  <strong>Splt/Jn</strong> button. If all goes well, the reconstructed item appears in the box, otherwise nothing happens. Likely problems include: insufficient number of parts, incomplete or corrupt parts, parts belonging to different sets.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=3-6CNa6iNKc" target="_blank">https://www.youtube.com/watch?v=3-6CNa6iNKc</a></p>
  </div>
  <hr style="background-color: #c0c0c0">
     
  <div id="cc5" style="cursor:pointer">
<h3>Convert a PassLok item (Lock, message, etc.) into fake text</h3>
  </div>
  <div id="c5" class="texter">  
<p>1. Check that the item to be converted into fake text is in the main box. Then click the &#x25B6; button.</p>
<p>2. If you wish to make fake text that is not English, you will have to change the cover text using the process described in the next help item.</p>
<p>3. The <strong>Words</strong> button replaces each character of the text with a word from the cover text; the recipient of the message thus encoded must have the same cover text. The <strong>Spaces</strong> button encodes the text into the spaces of the cover text; the recipient does not need to have the original cover text, but it takes seven times more words than with the other mode. When you click either button, the contents of the box are converted into fake text using the current cover, replacing the previous contents.</p>
<p>4. You can now email the fake text, which to an email scanner will be nearly indistinguishable from real text. You can change the punctuation and merge or split lines without changing the encoded material. If you used Spaces encoding, you should be careful not to add or delete any spaces within the encoded text, but it is okay to add more text to complete the last sentence, which may contain additional spaces.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=KwAETd2pgy4" target="_blank">https://www.youtube.com/watch?v=KwAETd2pgy4</a></p></div>
  <hr style="background-color: #c0c0c0">
  
  <div id="cc6" style="cursor:pointer">
<h3>Retrieve the original PassLok item from fake text</h3>
  </div>
  <div id="c6" class="texter">
<p>1. Put the fake text in the box on the main screen. Then click the &#x25B6; button.</p>
<p>2. If the fake text was encoded with the Words method, you will have to load first the cover text used to do the encoding, using the process described in the next help item.</p>
<p>3. Now click either the <strong>Words</strong> button or the <strong>Spaces</strong> button, it doesn't matter which. If successful, the fake text in the box is converted back into the original item and displayed in the box, replacing the fake text.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=KwAETd2pgy4" target="_blank">https://www.youtube.com/watch?v=KwAETd2pgy4</a></p></div>
  <hr style="background-color: #c0c0c0">
 
  <div id="cc7" style="cursor:pointer">
<h3>Display or change the cover text used for fake text</h3>
  </div>
  <div id="c7" class="texter">
<p>To display the current cover text (which is the default cover text after reloading PassLok), click the &#x25B6; button, and then the <strong>Cover</strong> button (short for Cover Text) with the box empty.</p>
<p>To change the cover text (this is necessary to make fake text in a language that is not English):</p>
<p>1. Copy a sufficiently long text (must have at least 70 different words) and paste it into the main box.</p>
<p>2. Click the &#x25B6; button, and then the <strong>Cover</strong> button.</p>
<p>3. If the change is successful, the box goes blank. If the change is unsuccessful, a message above the box will say why. Typically, failure to change the cover text is due to not having a sufficient number of different words. Use a longer text and try again.</p>
<p>4. The recipient of your messages turned into fake text must have the same cover text in order to retrieve a text encoded with the<strong> Words</strong> button. One way to ensure this when using a non-English language is to display the default cover text, copy it into a translation utility such as Google Translate, and then use the translation as the new cover text.</p>
<p>5. Since the cover text is a (weak) sort of password for a Words-encoded item, it may be good to put special cover texts in your local directory. To do this, go to the <strong>Locks</strong> screen , write a new name in the upper box, then paste the cover text in the lower box, and click <strong>Save</strong>. The cover text can be retrieved like any other stored item, and it will be automatically loaded if displayed on the Locks screen.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=sv8epS3qBH8" target="_blank">https://www.youtube.com/watch?v=sv8epS3qBH8</a></p></div>
  <hr style="background-color: #c0c0c0">
    
  <div id="cc8" style="cursor:pointer">  
  <h3>Load a file (image, on mobile devices) to be locked, signed, or split</h3>
  </div>
  <div id="c8" class="texter">
  <p>1. Click the &#x25B6; button, and then the button at the bottom of the screen. Different browsers put different labels on it, such as <strong>"Browse"</strong>, <strong>"Choose File"</strong>, and so forth.</p>
  <p>2. A dialog will appear so you can navigate to the file. Mobile devices, unless they are jailbroken or rooted, restrict the user to images stored in the device or acquired with the built-in camera. Be aware that pictures taken by the camera are usually too large for PassLok to handle. If all goes well, the file or image loads into the box as a (long) piece of gibberish text, with some identifying information at the top.</p>
  <p>3. Now you can lock it, sign it, or split it like a regular piece of text. The process to retrieve the original file is explained in the help item below.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=v6jnKzzlwS0" target="_blank">https://www.youtube.com/watch?v=v6jnKzzlwS0</a></p>
  </div>
    <hr style="background-color: #c0c0c0">
  
  <div id="cc9" style="cursor:pointer">  
  <h3>Retrieve a file (image, on mobile devices) from encoded text</h3>
  </div>
    <div id="c9" class="texter">
  <p>1. Make sure the encoded file, which presumably has been obtained by unlocking or merging parts, is in the main box. Click the &#x25B6; button.</p>
  <p>2. Click the <strong>Save</strong> button at the bottom of the screen. What happens next depends on the browser. Chrome and Firefox will save the file, using the original name if not already taken by another file, into the default location for downloads. Safari does the same, but gives it a generic name that you will have to edit later. Internet Explorer doesn't do anything. Mobile browsers normally open another tab displaying the file contents if the file type is recognized, from where you can send it to another app.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=v6jnKzzlwS0" target="_blank">https://www.youtube.com/watch?v=v6jnKzzlwS0</a></p>
  </div>
    <hr style="background-color: #c0c0c0">

 <div id="cc10" style="cursor:pointer">  
  <h3>Hide a PassLok item inside an image (non-mobile only)</h3>
 </div>
  <div id="c10" class="texter">
 <p>1. Make sure the item to be hidden is in the main box, and it remains in the box after clicking the &#x25B6; button . Then click the <strong>Txt/Img</strong> button above the box.</p>
<p>2. A new screen appears to load the image where the text is to be hidden. To do so, click the <strong>"Choose File"</strong> or <strong>"Browse"</strong> button (browsers vary on the name). A dialog will appear, where you can choose the image. Bear in mind that images taken with a mobile camera are usually too large for PassLok to be able to use them for hiding items, because of the processing required.</p>
    <p>3. When you see the image, click the <strong>Hide</strong> button. Processing will start, and a message will say when it is completed. At this point, you can right-click on the image and another dialog will offer to save the image. This image now contains the item from the main box, even though it looks the same as before.</p>
    <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=lRIYi6IDNzY" target="_blank">https://www.youtube.com/watch?v=lRIYi6IDNzY</a></p>
 </div>
    <hr style="background-color: #c0c0c0">
   
 <div id="cc11" style="cursor:pointer">  
  <h3>Retrieve the PassLok item hidden inside an image (non-mobile only)</h3>
 </div>
  <div id="c11" class="texter">
      <p>1. Navigate to the image hiding screen by clicking &#x25B6;, and then <strong>Txt/Img</strong>.</p>
      <p>2. Click <strong>Choose File</strong> or <strong>Browse</strong> (browsers vary on this) and select the image containing the hidden item.</p>
      <p>3. When the image displays on the screen, click the <strong>Reveal</strong> button. Processing begins, and a message appears when it concludes, saying that the hidden item has been retrieved. If you click <strong>Back</strong> at this point, you will see the item in the big box. If the image contained nothing, a message will tell you.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=lRIYi6IDNzY" target="_blank">https://www.youtube.com/watch?v=lRIYi6IDNzY</a></p>
 </div>
   <hr style="background-color: #c0c0c0">
  
  <div id="cc12" style="cursor:pointer">
<h3>Verify PassLok's integrity</h3>
</div>
<div id="c12" class="texter">
<p>The biggest vulnerability of PassLok is how easy it is to view, <strong>and consequently modify</strong> the html code. As mentioned in our Privacy Statement, we will never weaken the underlying cryptography, but others might. Even though we are taking pains to ensure that PassLok is delivered to you in the most secure way compatible with our budget, <strong>you should still make sure that you have obtained the genuine code.</strong></p>
<p>If you have obtained PassLok from the Chrome web store, then you are trusting Google with ensuring that the code has not been tampered with. They have powerful methods involving digital signatures recognized by the Chrome browser, which are better than the method for checking the regular html version of PassLok.</p>
<p>The method described at the end of the &quot;get PassLok&quot; section of the <a href='http://passlok.weebly.com/get-passlok.html'>PassLok informational website</a>, to verify the integrity of PassLok in html form, is less than perfect but it works in most situations. Once you are sure that your copy of PassLok is pristine, you can save it and run it as many times as you want from its storage location without having to connect to the page server again. Essentially, the method involves loading the source code, obtaining its SHA256 hash using an external utility such as, and comparing that with what the author, Francisco Ruiz, reads in a video.</p>
<p>A lot of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=1QSRvme3pVQ" target="_blank">https://www.youtube.com/watch?v=1QSRvme3pVQ</a></p>
</div>

	<hr style="background-color: #c0c0c0">
  <button class="cssbutton" id="closeextrahelpButton2" value="< Back" >&#x25C0; Back</button>
</div>

<div id="quiz" class="texter" style="display: none;">
	<button class="cssbutton" id="closequizButton1" value="< Back" style="width:185px">&#x25C0; Back to main Help</button>
	<hr style="background-color: #c0c0c0">
    
<div id='qq1' style="cursor:pointer"> 
<h3>Which of these are correctly formatted Keys?</h3>
</div>
<div id="q1" class="texter">
<p>A. fjslk7798+fsdkj/fGJr</p>
<p>B. I'll eat 42 Bananas</p>
<p>C.   </p>
<p>D. All of the above</p>
<p>E. None of the above</p>
<div id='aans1' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans1" class="texter">
<p><strong>D</strong>. PassLok does not restrict the user to a particular set of characters. Any string that can be encoded as UTF-8 (most languages are) is valid for a Key</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq2' style="cursor:pointer">
<h3>This is how to write a secure Key:</h3>
</div>
<div id="q2" class="texter">
<p>A. Use capitals and smallcase letters</p>
<p>B. Use numbers and special characters</p>
<p>C. Make it long; at least 12 characters</p>
<p>D. If you use words that might be in a dictionary, misspell them</p>
<p>E. All of the above</p>
<div id='aans2' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans2" class="texter">
<p><strong>E</strong>. Using a variety of characters increases the number of different Keys that a hacker would have to try in order to guess the correct Key. Of course, the longer, the better. Since hackers try the words contained in dictionaries first, you'll do yourself a favor by not using those.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq3' style="cursor:pointer">
<h3>PassLok uses variable Key stretching</h3>
</div>
<div id="q3" class="texter">
<p>A. True. Computations take longer for shorter Keys</p>
<p>B. True. Computations take longer for weaker Keys</p>
<p>C. True. Computations are made shorter for weaker Keys</p>
<p>D. True. Encryption is done several times for weaker Keys</p>
<p>E. False. This would cause computations to take too long</p>
<div id='aans3' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans3" class="texter">
<p><strong>B</strong>. Key stretching essentially means that a new Key is derived from the user's Key after a lot of roundabout computations, and this new Key is the one actually used for locking, unlocking, and everything else. It does not involve multiple encryptions. PassLok uses the "scrypt" algorithm to lengthen the computations involving weaker Keys, as determined by PassLok's built-in Key strength meter. All features contributing to Key strength are considered, not just the length. If a user uses a Key that is scored as Weak or even Terrible, everything will be very sluggish, although it will still work. This forces hackers to spend a great deal of computer time to go through the weak Keys in their dictionaries, or risk missing those.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq4' style="cursor:pointer">
<h3>Which of these are correctly formatted Locks?</h3>
</div>
<div id="q4" class="texter">
<p>A. CGRrN5QjMtr+fp74nY+y93EaeHHBh/PTwvLpjL0hl9a2FuTP3mTGjPjMSrXIEmH4gaG41ea4GUkE81m8tDjwydL</p>
<p>B. PL17lok=CGRrN5QjMtr+fp74nY+y93EaeHHBh/PTwvLpjL0hl9a2FuTP3mTGjPjMSrXIEmH4gaG41ea4GUkE81m8tDjwydL=PL17lok</p>
<p>C. PL17lok=CGRrN5QjMtr+fp74nY+y93EaeHHBh/PTwvLpjL0hl9a2FuTP3mTGjPjMSrXIEmH4gaG41ea4GUkE81m8tDjwydL=PL17lok_https://www.youtube.com/watch?v=SYx-rH5yjA4</p>
<p>D. CGRrN5QjMtr+fp74nY+y93EaeHHBh/PTwvLpjL0hl9a2FuTP3mTGjPjMSrXIEmH4gaG41ea4GUkE81m8tDjwydL=http://vimeo.com/88048071</p>
<p>E. All of the above</p>
<div id='aans4' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans4" class="texter">
<p><strong>E</strong>. The core of a PassLok Lock consists of 87 base64 characters (smallcase and capital letters a to z, plus numbers 0 to 9, plus / and +). It may be bracketed by tags, which are separated by the core by = signs. PassLok detects these signs and uses as a Lock the longest string between them. Therefore, video URLs and other material can be added without affecting the function of a Lock. Not all 87-character base64 strings are valid Locks, however. Only about half of those are valid Locks, which PassLok will check right before using it. It is impossible to tell by visual inspection whether a given 87-character string is a valid Lock, however.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq5' style="cursor:pointer">
<h3>The relationship between a Key and a Lock is like this:</h3>
</div>
<div id="q5" class="texter">
<p>A. You get the Lock from the Key, but you cannot get the Key from the Lock</p>
<p>B. You get the Key from the Lock, but you cannot get the Lock from the Key</p>
<p>C. You can get either of them from the other</p>
<p>D. Key and Lock are independent from each other</p>
<p>E. None of the above</p>
<div id='aans5' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans5" class="texter">
<p><strong>A</strong>. You get the Lock from the Key, but it is impossible to get the Key from the Lock. This is why the Lock can be made public while the Key remains secret.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq6' style="cursor:pointer">
<h3>This is how PassLok secures an email message</h3>
</div>
<div id="q6" class="texter">
<p>A. The message is locked in PassLok, then the user copies it to any email program and sends it over unsecured channels</p>
<p>B. PassLok establishes a secure channel with the user, and then the message is sent to a server where it is locked before it is sent</p>
<p>C. Both sender and recipient connect to the same secure server, and thus the message is never sent over unsecured channels</p>
<p>D. The message is obfuscated but it is not really locked until it reaches the recipient</p>
<p>E. The recipient must first supply a password so the message can be locked before it is sent. This is done transparently to the sender.</p>
<div id='aans6' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans6" class="texter">
<p><strong>A</strong>. Locking and unlocking in PassLok involves no servers, and transmission takes place over unsecured channels, such as regular email. This implies that the message is locked before it leaves the sender's device. Answer E comes pretty close, but the recipient does not send a password or Key, which would be secret to everyone but the sender and might be compromised if sent over email; instead, the recipient sends a Lock, from which his/her Key cannot be obtained.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq7' style="cursor:pointer">
<h3>PassLok Tags are...</h3>
</div>
<div id="q7" class="texter">
<p>A. Strings placed at beginning and end of PassLok items, so PassLok knows what they are</p>
<p>B. Strings placed at beginning and end of PassLok items, so users know what they are</p>
<p>C. Necessary for PassLok to complete actions such as unlocking a message</p>
<p>D. A way to identify the author of a PassLok item</p>
<p>E. A way to include the date when a PassLok item was created</p>
<div id='aans7' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans7" class="texter">
<p><strong>B</strong>. Tags such as "PL17lok" and "PL16sig" tell the user that what is between the tags is a PassLok item (PL), the version under which they were created (1.7 and 1.6, respectively), since sometimes a specific version of PassLok is needed in order to handle an item successfully, and the type of item they are (a Lock and a signature, respectively). PassLok can tell what type of item it is dealing with even if the tags are absent, so long as the rest of the item is complete. The tags in no way identify the author or include any information other than what is mentioned above. If the user wishes to produce items bearing no tags, he/she can do so simply by checking the No tags checkbox.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq8' style="cursor:pointer">
<h3>These are the buttons I need to click in order to lock and unlock messages</h3>
</div>
<div id="q8" class="texter">
<p>A. <strong>Lck/Unl</strong> to lock, <strong>Sig/Ver</strong> to unlock</p>
<p>B. <strong>Sig/Ver</strong> to lock, <strong>Lck/Unl</strong> to unlock</p>
<p>C. <strong>Lck/Unl</strong> to lock, either <strong>Lck/Unl</strong> or <strong>Sig/Ver</strong> to unlock</p>
<p>D. <strong>Lck/Unl</strong> both to lock and to unlock</p>
<p>E. The button to be clicked depends on the locking mode</p>
<div id='aans8' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans8" class="texter">
<p><strong>D</strong>. The <strong>Lck/Unl</strong> button does everything related to locking and unlocking. PassLok detects if the main box contains a locked message, and if so, the locking mode used and proceeds to unlock regardless of the mode set with the checkboxes below. If no locked message is detected, PassLok proceeds to lock the message instead, using the mode set with the checkboxes.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq9' style="cursor:pointer">
<h3>Locking and unlocking in Anonymous mode works like this:</h3>
</div>
<div id="q9" class="texter">
<p>A. You lock with your Key and the recipient unlocks with your Lock</p>
<p>B. You lock with your Lock and the recipient unlocks with his/her Key</p>
<p>C. You lock with the recipient's Lock, and the recipient unlocks with his/her Key</p>
<p>D. You lock with the recipient's Key, and the recipient unlocks with your Lock</p>
<p>E. None of the above</p>
<div id='aans9' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans9" class="texter">
<p><strong>C</strong>. You lock with the recipient's Lock, and he/she unocks with his/her Key. Using your Key to lock a message would mean (assuming it were possible), that the message is going to be unlocked either with your Key, which would imply that you'd have to give your secret Key to someone else (a no-no in PassLok), or with your Lock, in which case the whole world would be able to unlock the message since the Lock is public. You cannot lock with the recipient's Key, since you don't have it. Locking with your Lock would imply that the recipient has your Key, which he doesn't.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq10' style="cursor:pointer">
<h3>Regardless of the locking mode selected, I can still use a shared Key to lock a message</h3>
</div>
<div id="q10" class="texter">
<p>A. True, and the message would be unlocked with the recipient's secret Key</p>
<p>B. False. Sharing a Key is a no-no in PassLok</p>
<p>C. False. This is possible sometimes, but not in all modes</p>
<p>D. True, and the message would be unlocked with the same shared Key used to lock it</p>
<p>E. None of the above</p>
<div id='aans10' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans10" class="texter">
<p><strong>D</strong>. You can always lock a message with a shared Key, different from your secret Key, and then the message would be unlocked with the same shared Key. A shared Key, like a secret Key, can be any string that can be written with UTF-8 characters. If it contains exactly 87 characters, and those characters are of the base64 set, it will be mistakien for a Lock, so this particular combination should be avoided.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq11' style="cursor:pointer">
<h3>When locking and unlocking in Signed mode...</h3>
</div>
<div id="q11" class="texter">
<p>A. Both the sender and the recipent must have the same Key and the same Lock</p>
<p>B. The recipient must have the sender's Lock</p>
<p>C. The sender must have the recipient's Lock</p>
<p>D. Both sender and recipient must have both Locks</p>
<p>E. None of the above.</p>
<div id='aans11' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans11" class="texter">
<p><strong>D</strong>. Both sender and recipient must have both Locks. Each party obviously has his/her own Lock. To lock a message in any mode, the sender needs to have the recipient's Lock. In signed mode, the recipient must additionally have the sender's Lock so the origin of the locked message can be verified.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq12' style="cursor:pointer">
<h3>The locked message always contains information about the sender or recipient that can be read without unlocking</h3>
</div>
<div id="q12" class="texter">
<p>A. False. A locked message contains no information at all identifying sender or recipient</p>
<p>B. False. Only the recipient's identity could be found, by matching his/her Lock</p>
<p>C. False. Only the sender's identity can be found, since his/her Lock was involved in locking the message</p>
<p>D. False. Part of the recipient's Lock or shared Key is included, but it is encrypted</p>
<p>E. True. The recipients need to know what part of the message is meant for them, so there is always some identifying information</p>
<div id='aans12' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans12" class="texter">
<p><strong>D</strong>. Regular-length locked messages can be locked for multiple recipients by encrypting the special message Key individually for each recipient. The encrypted Keys are identified by a tag, which is made from some information pertaining to each recipient, but it is also encrypted so no one else can read it. Concerning the sender, the only way to tell who sent a message is by unlocking a message locked in Signed or PFS modes.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq13' style="cursor:pointer">
<h3>PFS mode means this:</h3>
</div>
<div id="q13" class="texter">
<p>A. The message self-destructs after reading</p>
<p>B. Locked messages become unreadable to both sender and recipient after a while</p>
<p>C. The messages cannot be tracked over the Internet</p>
<p>D. Messages contain a hidden message</p>
<p>E. None of the above</p>
<div id='aans13' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans13" class="texter">
<p><strong>B</strong>. Messages locked in PFS mode use temporary Keys that are overwritten next time either party locks a message, so a message becomes unreadable even to the sender after the Key used to lock it has been changed, that is, after one more message from both sides. This does not mean that messages cannot be tracked over the Internet, which depends on the software used to transmit them, not on PassLok. Hidden messages are possible, but this is Decoy mode, not PFS. Finally, answer A is partially true: if a message is locked with both PFS mode and Short mode selected, it can only be onlocked once.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq14' style="cursor:pointer">
<h3>Short mode messages...</h3>
</div>
<div id="q14" class="texter">
<p>A. Are limited in length</p>
<p>B. Can be locked in any mode</p>
<p>C. Can contain hidden messages</p>
<p>D. Are limited to a single recipient</p>
<p>E. All of the above</p>
<div id='aans14' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans14" class="texter">
<p><strong>E</strong>. Short mode messages are limited to 160 characters (159 in some modes) after they are locked, so they can be texted easily. This imposes even stricter limits on the length of the unlocked message. All modes are possible: Anonymous, Signed, or PFS, both using Locks and shared Keys. They can also contain a shorter hidden message. Finally, space limitations make it impossible to have more than one recipient who would be able to unlock the message.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq15' style="cursor:pointer">
<h3>In Decoy mode...</h3>
</div>
<div id="q15" class="texter">
<p>A. The same Key or Lock is used to lock a second message</p>
<p>B. A popup automatically asks for the Decoy Password if the message contains a hidden message</p>
<p>C. It is possible to add a second message that is itself unlocked</p>
<p>D. The whole thing is a decoy. There is no real message in there</p>
<p>E. None of the above</p>
<div id='aans15' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans15" class="texter">
<p><strong>E</strong>. In decoy mode, a second message of limited length is locked under a different shared Key, which cannot be empty. Answer B comes closer to the truth, but not quite: a popup asking for a Decoy Password will appear whenever Decoy mode is selected for unlocking. There is no way to know whether or not a particular locked message has been locked using Decoy mode, and therefore may contain a hidden message.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq16' style="cursor:pointer">
<h3>You can lock messages for multiple recipients under these conditions:</h3>
</div>
<div id="q16" class="texter">
<p>A. Always except in Short mode</p>
<p>B. Always except in PFS mode</p>
<p>C. Always except in Decoy mode</p>
<p>D. Always, except when using a shared Key for at least one recipient</p>
<p>E. None of the above</p>
<div id='aans16' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans16" class="texter">
<p><strong>A</strong>. There is nothing preventing PassLok from locking a message for multiple recipients in any mode, except that it must include a portion meant for each recipient to unlock, and then the locked message would not fit within the 160-character limit of Short mode. Therefore, only one recipient is allowed in Short mode.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq17' style="cursor:pointer">
<h3>A digital signature is...</h3>
</div>
<div id="q17" class="texter">
<p>A. A random-looking string that reveals who locked a message</p>
<p>B. A special locking mode that authenticates the contents</p>
<p>C. The reverse of Anonymous locking</p>
<p>D. A special Key that you can actually share safely</p>
<p>E. A random-looking string that reveals who wrote a plain message</p>
<div id='aans17' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans17" class="texter">
<p><strong>E</strong>. A digital signature is neither a Lock, nor a Key, nor a locked message, nor the reverse of locking (although it somewhat looks like it). It is associated with a particular plain (not locked) text and with a secret Key. When you apply your secret Key to the plain message by means of the <strong>Sig/Ver</strong> button, a random-looking string is appended to the message, which remains plain to read. Then people can verify that it was you, the possessor of that particular secret Key, who did this, by applying the Lock matching that Key (the Lock is public, so they know it) to the message plus the signature and clicking <strong>Sig/Ver</strong> again.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq18' style="cursor:pointer">
<h3>The secret Key is stored...</h3>
</div>
<div id="q18" class="texter">
<p>A. In the local directory, unencrypted</p>
<p>B. In the local directory, encrypted</p>
<p>C. In the general directory, encrypted</p>
<p>D. Only between sessions, then it is deleted</p>
<p>E. Never, anywhere</p>
<div id='aans18' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans18" class="texter">
<p><strong>E</strong>. The secret Key is never stored anywhere within or outside PassLok. It is retained in a special input box while it is used, but it is deleted as soon as PassLok closes. If the Key is not used by any function within PassLok for five minutes, it is automatically deleted even though PassLok might still be running.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq19' style="cursor:pointer">
<h3>Items that can be stored in the local directory include:</h3>
</div>
<div id="q19" class="texter">
<p>A. Only Locks</p>
<p>B. Locks and shared Keys</p>
<p>C. Locks, shared Keys, and Lists</p>
<p>D. Locks, shared Keys, Lists, and Cover texts</p>
<p>E. Locks, shared Keys, Lists, Cover texts, Lists, and alternative secret Keys</p>
<div id='aans19' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans19" class="texter">
<p><strong>D</strong>. Just about anything that PassLok uses can be stored in the local directory. The exception is the secret Key, which is never stored anywhere. Its matching Lock is stored, however, and this is why users are advised to remove this stored Lock by clicking Reset on the Key screen if he/she decides to change the secret Key.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq20' style="cursor:pointer">
<h3>Items in the local directory...</h3>
</div>
<div id="q20" class="texter">
<p>A. Are stored permanently, and cannot be modified or removed</p>
<p>B. Are stored permanently, but can be modified or removed at any time</p>
<p>C. Are stored permanently, and they sync automatically across devices</p>
<p>D. Are stored permanently, and they sync automatically with the general PassLok directory</p>
<p>E. Are not stored permanently. When PassLok closes, they are deleted from memory</p>
<div id='aans20' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans20" class="texter">
<p><strong>B</strong>. The point of the local directory is that users can keep handy their contacts' Locks, etc. without having to look them up again. They only need to supply the name they gave to each particular item. If they don't remember it, they can list the complete directory and find it that way. Only the Chrome app version of PassLok syncs across devices, so long as the user logs into his/her Google account within Chrome (because this requires some sort of connection with a server, which PassLok does not have by default). The general directory, though handy, is entirely optional and accepts only Locks.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq21' style="cursor:pointer">
<h3>To lock a message for multiple recipients...</h3>
</div>
<div id="q21" class="texter">
<p>A. You write the recipients' names in the local directory, one per line, in the Locks lower box</p>
<p>B. You write the recipients' Locks, one per line, in the Locks lower box</p>
<p>C. You write the name of a List containing the recipients' Locks, in the Locks upper box</p>
<p>D. You write the name of a List containing the recipients' names in the directory, in the Locks upper box</p>
<p>E. Any of the above, or any combination of them</p>
<div id='aans21' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans21" class="texter">
<p><strong>E</strong>. PassLok will detect automatically if an item entered on its own line in the Locks lower box is itself a Lock or the name of a Lock. If the presumed name is not found in the local directory, PassLok will use it as a shared Key, but will warn you before in case this is a mistake. If you put all those items into a List, it is enough to begin typing the name of the List in the upper box. The only restriction is that Lists are not nested (Lists containing names of other Lists); Lists can be merged if necessary, though.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq22' style="cursor:pointer">
<h3>The general PassLok directory...</h3>
</div>
<div id="q22" class="texter">
<p>A. Is built into PassLok, so the program can retrieve other users' Locks as needed</p>
<p>B. Can be accessed from within PassLok and then there is some integration, but it is not necessarily loaded since it is a separate webpage</p>
<p>C. Is a completely separate website that has no integration with PassLok other than a button to load it, since it involves a server</p>
<p>D. Has no connection with the PassLok app, though its server is related to it</p>
<p>E. Is an entirely separate website from entirely different people. PassLok does not endorse it</p>
<div id='aans22' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans22" class="texter">
<p><strong>B</strong>. There is as much integration with the general PassLok directory as possible within the "no server" philosophy of PassLok. This means that the general directory, which necessarily involves a server, is actually a separate webpage that is blended as seamlessly as possible within PassLok. You can send your Lock from PasssLok to the directory (you only need to supply your email address, since the directory indexes Locks by email address and confirms changes by email, and click the <strong>Post</strong> button), and the directory can send Locks to PassLok (you still need to supply a name and click the <strong>Save</strong> button), but that's where the integration ends. The general directory page is not even loaded unless specifically requested.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq23' style="cursor:pointer">
<h3>To use my stored Locks in a different device...</h3>
</div>
<div id="q23" class="texter">
<p>A. I must use the Chrome app version of PassLok. It is not possible otherwise since the local direactory is tied to a particular device and browser</p>
<p>B. I can use the Chrome app, or I can export the entire local directory, and then import it into the new device</p>
<p>C. I can use the Chrome app, or I can export that particular Lock so that I can use it in another device</p>
<p>D. I can always get them from the general PassLok directory, since my local directory syncs automatically with the general directory</p>
<p>E. This cannot be done. The local directory is strictly local for security reasons</p>
<div id='aans23' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans23" class="texter">
<p><strong>B</strong>. The Chrome app version of PassLok syncs its local directory items, one at a time, through Google, and then the user can retrieve them from there by typing the entire name in the Locks upper box, followed by the Enter key. For the regular html version, however, users must first export their entire local directory so it can be imported into a different device. But this is not difficult to do; just click the <strong>Move</strong> button, followed by <strong>Mail</strong>. In most web-based email programs, such as gmail, a draft email containing the encrypted directory will be created immediately, which can be easily retrieved from another machine, and then automatically imported into PassLok as if unlocking a message. The general PassLok directory stores only one Lock at a time, and it must be done by the original owner of that Lock.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq24' style="cursor:pointer">
<h3>"Authenticating" a Lock means...</h3>
</div>
<div id="q24" class="texter">
<p>A. I downloaded the Lock from the general PassLok directory, which means it is good</p>
<p>B. I have verified a witness's digital signature attached to the Lock</p>
<p>C. I made sure that the Lock actually belongs to the person who claims ownership of it</p>
<p>D. I submitted it to the general PassLok directory, along with some personal information</p>
<p>E. I made a video of myself reading part of the Lock, and appended its URL  to the Lock before posting it</p>
<div id='aans24' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans24" class="texter">
<p><strong>C</strong>. A Lock should not be taken as authentic until you have made sure that it actually belongs to the person who claims to have made it. Otherwise, you may find yourself locking sensitive information for an interloper to read. One way to authenticate a Lock is when the owner has added a video of him/herself reading a portion of the Lock, or of its ID displayed right above it (easier to read), which you watch. If you recognize the person and the code being read matches what you've got, then you can consider the Lock as authentic. Getting the Lock from the general PassLok directory is not enough, since the general directory authenticates entries only by email confirmation, which could be faked by people having access to mail servers. Even though it is possible to do so, PassLok does not authenticate Locks by "web of trust" or similar signature-based schemes.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq25' style="cursor:pointer">
<h3>The PC and mobile versions of PassLok are identical</h3>
</div>
<div id="q25" class="texter">
<p>A. True. There is no difference at all between PassLok running on a computer vs. a smartphone</p>
<p>B. False. Either the mobile or the non-mobile code is downloaded to the device, depending on what the device is</p>
<p>C. True, but PassLok detects the platform it is running on, and behaves differently according to that</p>
<p>D. False. Chrome apps and extensions don't run on mobile devices (yet)</p>
<p>E. The distinction is meaningless, since the PassLok code is generated on-the-fly for any device</p>
<div id='aans25' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans25" class="texter">
<p><strong>C</strong>. There is only one html code for PassLok, but it runs differently on PCs and mobile devices. Some buttons behave differently, however. If you click Txt/Img on a PC, the image hiding screen appears; on a mobile device, the default texting app opens instead. This is because PCs usually don't have a default texting app, and mobile devices tend to modify images as they load them, making image hiding difficult. There are other differences arising from the non-mobile browsers ability to display at different resolutions and with different screen sizes. The packaged Chrome app (which at this point is not yet supported by mobile Chrome) has its code split among different files rather than all in one file because of Google restrictions, but is otherwise identical to the html version, including Chrome-specific functions that the html version cannot use.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq26' style="cursor:pointer">
<h3>"Authenticating" an html version of PassLok  means...</h3>
</div>
<div id="q26" class="texter">
<p>A. I have obtained it from a friend</p>
<p>B. I have downloaded it from one of the official mirrors</p>
<p>C. I have downloaded it from one of the official mirrors and verified its SHA256 checksum</p>
<p>D. I have downloaded it from one of the official mirrors, verified its SHA256 checksum, and compared it with what the author reads in a video</p>
<p>E. It is impossible to authenticate PassLok, so "authenticating" actually means getting a false sense of security</p>
<div id='aans26' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans26" class="texter">
<p><strong>D</strong>. Someone could hack into a PassLok server and change the code in subtle ways that make it insecure, so it is a good practice to audit the code (if you are adept in cryptography and web app programming) or, for the rest of us, at least make sure the code still is what the author wrote. If you do this, it doesn't really matter how you got the code. The standard way to authenticate the code is very much like for authenticating a Lock, except that you get the SHA256 of the entire code (using a separate utility, not PassLok itself), and then hopefully you recognize the author after having done it a few times. We're looking into engaging a celebrity to do this, but not yet ;-) If you have the Chrome app version, then Google is vouching for its integrity, so it all depends on whether or not you trust Google.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq27' style="cursor:pointer">
<h3>The Shamir Secret Sharing Scheme (SSSS) is a function that...</h3>
</div>
<div id="q27" class="texter">
<p>A. Turns text into several random-looking parts, some of which must be joined together to retrieve the original</p>
<p>B. Hides text inside images</p>
<p>C. Turns text into a different text, and back</p>
<p>D. Hides text within the spacing of another text</p>
<p>E. None of the above</p>
<div id='aans27' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans27" class="texter">
<p><strong>A</strong>. When you click the <strong>Splt/Jn</strong> button, a popup asks for the number of parts to make, and the minimum number that will be needed to retrieve the original. To reconstruct, paste in a sufficient number of parts form the same set, each on a separate line, and click the same button. If but one part is missing, it is impossible to retrieve even one bit of the original.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq28' style="cursor:pointer">
<h3>PassLok can disguise its output as text...</h3>
</div>
<div id="q28" class="texter">
<p>A. True. It converts each character into a word, which can be later converted back</p>
<p>B. True. It converts each character into a series of spaces, so the output is hidden in the spacing between words of a text</p>
<p>C. True, but the recipient must have the same Cover text to get the original item back</p>
<p>D. True, but this does not provide any real security</p>
<p>E. All of the above</p>
<div id='aans28' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans28" class="texter">
<p><strong>E</strong>. PassLok includes two ways to disguise its random-looking output as text: Words and Spaces. Using the Words method, each character is replaced by a word of the Cover text, which measn that the recipient must have the same Cover text. In the Spaces method, each characters is endoded as single or double spaces between words without altering the words of the Cover text, which the recipient does not need to have, at the expense of a greater length. Neither method provides real security, so PassLok will refuse to apply them to plain text.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq29' style="cursor:pointer">
<h3>PassLok can disguise its output as images...</h3>
</div>
<div id="q29" class="texter">
<p>A. False because, since the output is random-looking, the images will look like abstract paintings</p>
<p>B. True, but space is limited</p>
<p>C. False, since web browsers always change images as hey load</p>
<p>D. True, but one can tell that there is something hidden in the image</p>
<p>E. True, and this is more secure than hiding within text</p>
<div id='aans29' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans29" class="texter">
<p><strong>B</strong>. PassLok can hide its output within images by replacing the least significant digits of the color value of each pixel with the encoded characters.  The larger the number of pixels, the more material can be concealed. Current mobile browsers change images as they load, however, so decoding is only possible with non-mobile browsers. The resulting image is usually indistinguishable from the original, but this is not really secure because no password is needed to retrieve the original. Because of this, PassLok does not allow this function to be applied to plain text.</p>
</div>
</div>
<hr style="background-color: #c0c0c0">

<div id='qq30' style="cursor:pointer">
<h3>PassLok can lock and sign files, too...</h3>
</div>
<div id="q30" class="texter">
<p>A. False. PassLok is html code runnning in a browser, which is not allowed to alter local files</p>
<p>B. False. There is no way to load files into the PassLok windows</p>
<p>C. True. This works equally well on mobile and non-mobile</p>
<p>D. True, but some browsers don't do his well, especially mobile ones</p>
<p>E. True, but this does not provide any real security</p>
<div id='aans30' style="cursor:pointer">
<p><em>Click here for Answer:</em></p>
</div>
<div id="ans30" class="texter">
<strong>D</strong>. Files can be converted into base64 text and loaded into the main box, from where they can be locked or signed like any piece of text. Once unlocked, the file can be saved to the default Downloads area (or viewed, on mobile devices) with the click of a button. Current mobile  browsers are restricted to loading only images, unless they are rooted or jailbroken. Results vary ccording to the browser used. Chrome, Firefox, and Opera are the best. Safari loads files but saves them with a generic name, which must be edited later. Internet Explorer, as usual, has a lot of problems.</div>
</div>
<hr style="background-color: #c0c0c0">
  <button class="cssbutton" id="closequizButton2" value="< Back" style="width:185px">&#x25C0; Back to main Help</button>
</div>

<div id="lockdir" class="texter" style="display: none;" align="center">
  <button class="cssbutton" id="closelockdirButton" value="< Back" style="float: left;width:180px">&#x25C0; Back to PassLok</button>
    
    <iframe seamless id="lockdirframe" src="" style="width:100%;height:900px"></iframe>

</div>

<script>
//this is the part of the javascript code that must be within the body

	sjcl.random.startCollectors();											//start SJCL's built-in entropy collectors

    //  Clear out "sorry, no JavaScript" message from text box.
    document.getElementById('warning').value = "PassLok Privacy";
   	document.getElementById('warning').style.backgroundColor = "rgb(235, 255, 235)";

	var rowheight = document.getElementById('warning').clientHeight*0.9,						//get title size in pixels, for number of rows calculation. global variables
		isiPad = (navigator.userAgent.match(/iPad/i) != null),
		isiPhone = (navigator.userAgent.match(/iPhone|iPod/i) != null),
		isAndroidTablet = (navigator.userAgent.match(/mobile/i) == null && navigator.userAgent.match(/Android/i) != null && !isiPad && !isiPhone),
		isAndroidPhone= (navigator.userAgent.match(/mobile/i) != null && navigator.userAgent.match(/Android/i) != null && !isiPad && !isiPhone),
		angle = window.orientation;
	if(isAndroidPhone || isAndroidTablet){rowheight = rowheight*1.1}		//Android rows are fatter
	textrows();

//resizes text boxes so they fit within the window
function textrows(){
	if(isiPad || isAndroidTablet){												//first for iPad. Don't know how to detect other tablets
		if((angle==90)||(angle==-90)){
			document.getElementById('mainBox').rows=document.documentElement.clientHeight/rowheight-11					//landscape
		}else{document.getElementById('mainBox').rows=document.documentElement.clientHeight/rowheight*1.2-11}			//portrait
	}else{
		if((angle==90)||(angle==-90)){
			document.getElementById('mainBox').rows=document.documentElement.clientHeight/rowheight*0.9-11				//smartphone here and line below
		}else if(typeof window.orientation != 'undefined') {document.getElementById('mainBox').rows=document.documentElement.clientHeight/rowheight*1.25-11
		}else{document.getElementById('mainBox').rows=document.documentElement.clientHeight/rowheight*1.27-14}}				//non-mobile
	document.getElementById('mainBox').rows = document.getElementById('mainBox').rows*0.8;			//tweak factor for development
	if(document.getElementById('lockBox')!=null) document.getElementById('lockBox').rows = document.getElementById('mainBox').rows
	
	//fix for fat text in landscape mode
	if((angle==90)||(angle==-90)){
		document.getElementById('modes').innerHTML = '<span style="font-size:50%;color:red">' + document.getElementById('modes').innerHTML + '</span>'
	}
}
	
//functions for reading a file into the box, and for saving it later
function saveURLAsFile()
{
	var URLToWriteSplit = document.getElementById('mainBox').value.trim().split('\n');
	var fileNameToSaveAs = URLToWriteSplit[0].split(':')[1];
	if(URLToWriteSplit.length > 1){
		var content = URLToWriteSplit[1].trim()
	} else {
		var content = URLToWriteSplit[0].trim()
	};	
	var downloadLink = document.createElement("a");
	if(content.slice(0,4).toLowerCase()=='http'){							//this is for showing a webpage, such as an authenticating video
		downloadLink.target = '_blank'
	} else if(content.slice(0,4).toLowerCase()=='data'){					//regular save of encoded file
		downloadLink.download = fileNameToSaveAs;
		downloadLink.innerHTML = "Download File";
	} else {																//to save contents as text file
		var textFileAsBlob = new Blob([document.getElementById('mainBox').value.trim()], {type:'text/plain'});
		downloadLink.download = prompt("The box contents will be saved as a text file. Please enter a name for it.");
		downloadLink.innerHTML = "Download File";
		content = window.URL.createObjectURL(textFileAsBlob);	
	}	
	if (window.webkitURL != null)
	{
		// Chrome allows the link to be clicked
		// without actually adding it to the DOM.
		downloadLink.href = content;
	}
	else
	{
		// Firefox requires the link to be added to the DOM
		// before it can be clicked.
		downloadLink.href = content;
		downloadLink.onclick = destroyClickedElement;
		downloadLink.style.display = "none";
		document.body.appendChild(downloadLink);
	}
	downloadLink.click();	
}

function destroyClickedElement(event)
{
	document.body.removeChild(event.target);
}

//this one is called by window.onload below
function loadFileAsURL()
{
	var fileToLoad = document.getElementById("fileToLoad").files[0];

	var fileReader = new FileReader();
	fileReader.onload = function(fileLoadedEvent) 
	{
		var fileName = fileToLoad.name;
		var URLFromFileLoaded = fileLoadedEvent.target.result;
		document.getElementById('mainBox').value = "filename:" + fileName + "\n" + URLFromFileLoaded;
	};
	fileReader.readAsDataURL(fileToLoad, "UTF-8");
}

// initialize things
window.onload = function() {
	
	if(typeof window.orientation == 'undefined') document.getElementById('preview').style.width = "40%"		//smaller image on PCs
	
	window.addEventListener("resize", function() { textrows() }, false)	    //resize if the window changes
	
	//start with intro screen if "myself" entry in lockDB is empty
	if(!lockDB['myself']){
		document.getElementById('videotutorial').src = "https://www.youtube.com/embed/UxgrES_CGcg";
		document.getElementById('mainscr').style.display = "none";
		document.getElementById('keyscr').style.display = "none";
		document.getElementById('shadow').style.display = "none";
		document.getElementById('introscr').style.display = "block";
	}
	
	//this one for loading files into extra screen
	var fileinput = document.getElementById('fileToLoad');
    fileinput.addEventListener('change', loadFileAsURL, false);
	fileinput.addEventListener('blur', ce);
	fileinput.addEventListener('focus', ce);
	
    // add action to the file input
    var input = document.getElementById('file');
    input.addEventListener('change', importImage);
	input.addEventListener('blur', ce);
	input.addEventListener('focus', ce);

    // add action to the encode button
    var encodeButton = document.getElementById('encode');
    encodeButton.addEventListener('click', encodeImage);
	encodeButton.addEventListener('blur', ce);
	encodeButton.addEventListener('focus', ce);

    // add action to the decode button
    var decodeButton = document.getElementById('decode');
    decodeButton.addEventListener('click', decodeImage);
	decodeButton.addEventListener('blur', ce);
	decodeButton.addEventListener('focus', ce);
	
	//button code moved from html page, used to be inline

	var myKeyButton = document.getElementById('myKeyButton');
    myKeyButton.addEventListener('click', any2key);
	myKeyButton.addEventListener('blur', ce);
	myKeyButton.addEventListener('focus', ce);
	
	var main2lockButton = document.getElementById('main2lockButton');
    main2lockButton.addEventListener('click', main2lock);
	main2lockButton.addEventListener('blur', ce);
	main2lockButton.addEventListener('focus', ce);
	
	var selectMainButton = document.getElementById('selectMainButton');
   	selectMainButton.addEventListener('click', selectMain);
	selectMainButton.addEventListener('blur', ce);
	selectMainButton.addEventListener('focus', ce);
	
	var clearMainButton = document.getElementById('clearMainButton');
   	clearMainButton.addEventListener('click', clearMain);
	clearMainButton.addEventListener('blur', ce);
	clearMainButton.addEventListener('focus', ce);

	var mainBox = document.getElementById('mainBox');
   	mainBox.addEventListener('keyup', charsLeft);
	mainBox.addEventListener('keydown', ce);
	mainBox.addEventListener('blur', ce);
	mainBox.addEventListener('focus', ce);
	
	var openmainhelpButton = document.getElementById('openmainhelpButton');
   	openmainhelpButton.addEventListener('click', openmainhelp);
	openmainhelpButton.addEventListener('blur', ce);
	openmainhelpButton.addEventListener('focus', ce);
	
	var decryptButton = document.getElementById('decryptButton');
   	decryptButton.addEventListener('click', Decrypt_text);
	decryptButton.addEventListener('blur', ce);
	decryptButton.addEventListener('focus', ce);
	
	var verifyButton = document.getElementById('verifyButton');
   	verifyButton.addEventListener('click', Verifyhash);
	verifyButton.addEventListener('blur', ce);
	verifyButton.addEventListener('focus', ce);
	
	var main2extraButton = document.getElementById('main2extraButton');
   	main2extraButton.addEventListener('click', main2extra);
	main2extraButton.addEventListener('blur', ce);
	main2extraButton.addEventListener('focus', ce);
	
	var extra2mainButton = document.getElementById('extra2mainButton');
   	extra2mainButton.addEventListener('click', extra2main);
	extra2mainButton.addEventListener('blur', ce);
	extra2mainButton.addEventListener('focus', ce);
		
	var sendMailButton = document.getElementById('sendMailButton');
   	sendMailButton.addEventListener('click', sendMail);
	sendMailButton.addEventListener('blur', ce);
	sendMailButton.addEventListener('focus', ce);
	
	var sendSMSButton = document.getElementById('sendSMSButton');
   	sendSMSButton.addEventListener('click', sendSMS);
	sendSMSButton.addEventListener('blur', ce);
	sendSMSButton.addEventListener('focus', ce);
		
	var secretshareButton = document.getElementById('secretshareButton');
   	secretshareButton.addEventListener('click', secretshare);
	secretshareButton.addEventListener('blur', ce);
	secretshareButton.addEventListener('focus', ce);	
	
	var openextrahelpButton = document.getElementById('openextrahelpButton');
   	openextrahelpButton.addEventListener('click', openextrahelp);
	openextrahelpButton.addEventListener('blur', ce);
	openextrahelpButton.addEventListener('focus', ce);
	
	var wordsButton = document.getElementById('wordsButton');
   	wordsButton.addEventListener('click', words);
	wordsButton.addEventListener('blur', ce);
	wordsButton.addEventListener('focus', ce);
	
	var spacesButton = document.getElementById('spacesButton');
   	spacesButton.addEventListener('click', spaces);
	spacesButton.addEventListener('blur', ce);
	spacesButton.addEventListener('focus', ce);
	
	var coverButton = document.getElementById('coverButton');
   	coverButton.addEventListener('click', box2cover);
	coverButton.addEventListener('blur', ce);
	coverButton.addEventListener('focus', ce);
	
	var savefileButton = document.getElementById('savefileButton');
   	savefileButton.addEventListener('click', saveURLAsFile);
	savefileButton.addEventListener('blur', ce);
	savefileButton.addEventListener('focus', ce);
	
	var image2extraButton = document.getElementById('image2extraButton');
   	image2extraButton.addEventListener('click', image2extra);
	image2extraButton.addEventListener('blur', ce);
	image2extraButton.addEventListener('focus', ce);
	
	var lock2mainButton = document.getElementById('lock2mainButton');
   	lock2mainButton.addEventListener('click', lock2main);
	lock2mainButton.addEventListener('blur', ce);
	lock2mainButton.addEventListener('focus', ce);
	
	var lock2dirButton = document.getElementById('lock2dirButton');
   	lock2dirButton.addEventListener('click', lock2dir);
	lock2dirButton.addEventListener('blur', ce);
	lock2dirButton.addEventListener('focus', ce);
	
	var clearLocksButton = document.getElementById('clearLocksButton');
   	clearLocksButton.addEventListener('click', clearLocks);
	clearLocksButton.addEventListener('blur', ce);
	clearLocksButton.addEventListener('focus', ce);
	
	var locknameBox = document.getElementById('locknameBox');
   	locknameBox.addEventListener('keyup', locknameKeyup);
	locknameBox.addEventListener('keydown', ce);
	locknameBox.addEventListener('blur', ce);
	locknameBox.addEventListener('focus', ce);	
	
	var addLockButton = document.getElementById('addLockButton');
   	addLockButton.addEventListener('click', addLock);
	addLockButton.addEventListener('blur', ce);
	addLockButton.addEventListener('focus', ce);
	
	var removeLockButton = document.getElementById('removeLockButton');
   	removeLockButton.addEventListener('click', removeLock);
	removeLockButton.addEventListener('blur', ce);
	removeLockButton.addEventListener('focus', ce);
	
	var resetPFSButton = document.getElementById('resetPFSButton');
   	resetPFSButton.addEventListener('click', resetPFS);
	resetPFSButton.addEventListener('blur', ce);
	resetPFSButton.addEventListener('focus', ce);
	
	var addToListButton = document.getElementById('addToListButton');
   	addToListButton.addEventListener('click', addToList);
	addToListButton.addEventListener('blur', ce);
	addToListButton.addEventListener('focus', ce);
	
	var lockBox = document.getElementById('lockBox');
   	lockBox.addEventListener('keyup', ce);
	lockBox.addEventListener('keydown', ce);
	lockBox.addEventListener('blur', ce);
	lockBox.addEventListener('focus', ce);
	
	var openlockhelpButton = document.getElementById('openlockhelpButton');
   	openlockhelpButton.addEventListener('click', openlockhelp);
	openlockhelpButton.addEventListener('blur', ce);
	openlockhelpButton.addEventListener('focus', ce);
	
	var showLockDBButton = document.getElementById('showLockDBButton');
   	showLockDBButton.addEventListener('click', showLockDB);
	showLockDBButton.addEventListener('blur', ce);
	showLockDBButton.addEventListener('focus', ce);
	
	var mergeLockDBButton = document.getElementById('mergeLockDBButton');
   	mergeLockDBButton.addEventListener('click', mergeLockDB);
	mergeLockDBButton.addEventListener('blur', ce);
	mergeLockDBButton.addEventListener('focus', ce);
	
	var moveLockDBButton = document.getElementById('moveLockDBButton');
   	moveLockDBButton.addEventListener('click', moveLockDB);
	moveLockDBButton.addEventListener('blur', ce);
	moveLockDBButton.addEventListener('focus', ce);
	
	var exitKeyButton = document.getElementById('exitKeyButton');
   	exitKeyButton.addEventListener('click', exitKey);
	
	var clearKeyButton = document.getElementById('clearKeyButton');
   	clearKeyButton.addEventListener('click', clearKey);
	clearKeyButton.addEventListener('blur', ce);
	clearKeyButton.addEventListener('focus', ce);
	
	var pwdBox = document.getElementById('pwd');
   	pwdBox.addEventListener('keyup', pwdKeyup);
	
	var showKey = document.getElementById('showKey');
   	showKey.addEventListener('click', showsec);
	showKey.addEventListener('blur', ce);
	showKey.addEventListener('focus', ce);
	
	var makelockButton = document.getElementById('makelockButton');
   	makelockButton.addEventListener('click', fillkeys);
	makelockButton.addEventListener('blur', ce);
	makelockButton.addEventListener('focus', ce);
	
	var openkeyhelpButton = document.getElementById('openkeyhelpButton');
   	openkeyhelpButton.addEventListener('click', openkeyhelp);
	openkeyhelpButton.addEventListener('blur', ce);
	openkeyhelpButton.addEventListener('focus', ce);
	
	var clearIntroButton = document.getElementById('clearIntroButton');
   	clearIntroButton.addEventListener('click', clearIntro);
	clearIntroButton.addEventListener('blur', ce);
	clearIntroButton.addEventListener('focus', ce);
	
	var pwdIntroBox = document.getElementById('pwdIntro');
   	pwdIntroBox.addEventListener('keyup', introKeyup);
	pwdIntroBox.addEventListener('blur', ce);
	pwdIntroBox.addEventListener('focus', ce);
	
	var showIntroKey = document.getElementById('showIntroKey');
   	showIntroKey.addEventListener('click', showIntro);
	showIntroKey.addEventListener('blur', ce);
	showIntroKey.addEventListener('focus', ce);
	
	var makelockIntroButton = document.getElementById('makelockIntroButton');
   	makelockIntroButton.addEventListener('click', makelockIntro);
	makelockIntroButton.addEventListener('blur', ce);
	makelockIntroButton.addEventListener('focus', ce);
	
	var decoyPwdIn = document.getElementById('decoyPwdIn');
   	decoyPwdIn.addEventListener('keyup', decoyKeyup);
	decoyPwdIn.addEventListener('keydown', ce);
	decoyPwdIn.addEventListener('blur', ce);
	decoyPwdIn.addEventListener('focus', ce);
	
	var decoyText = document.getElementById('decoyText');
   	decoyText.addEventListener('keyup', ce);
	decoyText.addEventListener('keydown', ce);
	decoyText.addEventListener('blur', ce);
	decoyText.addEventListener('focus', ce);
	
	var showdecIn = document.getElementById('showdecIn');
   	showdecIn.addEventListener('click', showdecoyIn);
	showdecIn.addEventListener('blur', ce);
	showdecIn.addEventListener('focus', ce);
	
	var submitDecoyButton = document.getElementById('submitDecoyButton');
   	submitDecoyButton.addEventListener('click', submitDecoyIn);
	submitDecoyButton.addEventListener('blur', ce);
	submitDecoyButton.addEventListener('focus', ce);
	
	var cancelDecoyButton = document.getElementById('cancelDecoyButton');
   	cancelDecoyButton.addEventListener('click', closebox);
	cancelDecoyButton.addEventListener('blur', ce);
	cancelDecoyButton.addEventListener('focus', ce);
	
	var decoyPwdOut = document.getElementById('decoyPwdOut');
   	decoyPwdOut.addEventListener('keyup', decoyKeyupOut);
	decoyPwdOut.addEventListener('keydown', ce);
	decoyPwdOut.addEventListener('blur', ce);
	decoyPwdOut.addEventListener('focus', ce);

	var showdecOut = document.getElementById('showdecOut');
   	showdecOut.addEventListener('click', showdecoyOut);
	showdecOut.addEventListener('blur', ce);
	showdecOut.addEventListener('focus', ce);
	
	var submitDecoy2Button = document.getElementById('submitDecoy2Button');
   	submitDecoy2Button.addEventListener('click', submitDecoyOut);
	submitDecoy2Button.addEventListener('blur', ce);
	submitDecoy2Button.addEventListener('focus', ce);
	
	var cancelDecoy2Button = document.getElementById('cancelDecoy2Button');
   	cancelDecoy2Button.addEventListener('click', closebox);
	cancelDecoy2Button.addEventListener('blur', ce);
	cancelDecoy2Button.addEventListener('focus', ce);
	
	var partsIn = document.getElementById('partsIn');
   	partsIn.addEventListener('keyup', partsKeyup);
	partsIn.addEventListener('keydown', ce);
	partsIn.addEventListener('blur', ce);
	partsIn.addEventListener('focus', ce)
	
	var submitPartsButton = document.getElementById('submitPartsButton');
   	submitPartsButton.addEventListener('click', submitParts);
	submitPartsButton.addEventListener('blur', ce);
	submitPartsButton.addEventListener('focus', ce);
	
	var cancelPartsButton = document.getElementById('cancelPartsButton');
   	cancelPartsButton.addEventListener('click', closebox);
	cancelPartsButton.addEventListener('blur', ce);
	cancelPartsButton.addEventListener('focus', ce);
	
	var closemainhelpButton = document.getElementById('closemainhelpButton');
   	closemainhelpButton.addEventListener('click', closemainhelp);
	closemainhelpButton.addEventListener('blur', ce);
	closemainhelpButton.addEventListener('focus', ce);
	
	var closemainhelpButton2 = document.getElementById('closemainhelpButton2');
   	closemainhelpButton2.addEventListener('click', closemainhelp);
	closemainhelpButton2.addEventListener('blur', ce);
	closemainhelpButton2.addEventListener('focus', ce);
	
	var closeextrahelpButton = document.getElementById('closeextrahelpButton');
   	closeextrahelpButton.addEventListener('click', closeextrahelp);
	closeextrahelpButton.addEventListener('blur', ce);
	closeextrahelpButton.addEventListener('focus', ce);
	
	var closeextrahelpButton2 = document.getElementById('closeextrahelpButton2');
   	closeextrahelpButton2.addEventListener('click', closeextrahelp);
	closeextrahelpButton2.addEventListener('blur', ce);
	closeextrahelpButton2.addEventListener('focus', ce);
	
	var closelockhelpButton = document.getElementById('closelockhelpButton');
   	closelockhelpButton.addEventListener('click', closelockhelp);
	closelockhelpButton.addEventListener('blur', ce);
	closelockhelpButton.addEventListener('focus', ce);
	
	var closelockhelpButton2 = document.getElementById('closelockhelpButton2');
   	closelockhelpButton2.addEventListener('click', closelockhelp);
	closelockhelpButton2.addEventListener('blur', ce);
	closelockhelpButton2.addEventListener('focus', ce);
	
	var closelockdirButton = document.getElementById('closelockdirButton');
   	closelockdirButton.addEventListener('click', dir2lock);
	closelockdirButton.addEventListener('blur', ce);
	closelockdirButton.addEventListener('focus', ce);
	
	var closequizButton1 = document.getElementById('closequizButton1');
   	closequizButton1.addEventListener('click', closequiz);
	closequizButton1.addEventListener('blur', ce);
	closequizButton1.addEventListener('focus', ce);
	
	var closequizButton2 = document.getElementById('closequizButton2');
   	closequizButton2.addEventListener('click', closequiz);
	closequizButton2.addEventListener('blur', ce);
	closequizButton2.addEventListener('focus', ce);
	
	var openquizButton = document.getElementById('openquizButton');
   	openquizButton.addEventListener('click', openquiz);
	openquizButton.addEventListener('blur', ce);
	openquizButton.addEventListener('focus', ce);

//for the help screens	
	document.getElementById('aa1').addEventListener('click', function() {openClose('a1')});
	document.getElementById('aa2').addEventListener('click', function() {openClose('a2')});
	document.getElementById('aa3').addEventListener('click', function() {openClose('a3')});
	document.getElementById('aa4').addEventListener('click', function() {openClose('a4')});
	document.getElementById('aa5').addEventListener('click', function() {openClose('a5')});
	document.getElementById('aa6').addEventListener('click', function() {openClose('a6')});
	document.getElementById('aa7').addEventListener('click', function() {openClose('a7')});
	document.getElementById('aa8').addEventListener('click', function() {openClose('a8')});
	document.getElementById('aa9').addEventListener('click', function() {openClose('a9')});
	document.getElementById('aa10').addEventListener('click', function() {openClose('a10')});
	document.getElementById('aa11').addEventListener('click', function() {openClose('a11')});
	document.getElementById('aa12').addEventListener('click', function() {openClose('a12')});
	document.getElementById('aa13').addEventListener('click', function() {openClose('a13')});
	document.getElementById('aa14').addEventListener('click', function() {openClose('a14')});
	document.getElementById('aa15').addEventListener('click', function() {openClose('a15')});
	document.getElementById('aa16').addEventListener('click', function() {openClose('a16')});
	document.getElementById('aa17').addEventListener('click', function() {openClose('a17')});
	document.getElementById('aa18').addEventListener('click', function() {openClose('a18')});
	document.getElementById('aa19').addEventListener('click', function() {openClose('a19')});
	document.getElementById('aa20').addEventListener('click', function() {openClose('a20')});
	document.getElementById('aa21').addEventListener('click', function() {openClose('a21')});
	document.getElementById('aa22').addEventListener('click', function() {openClose('a22')});
	
	document.getElementById('bb1').addEventListener('click', function() {openClose('b1')});
	document.getElementById('bb2').addEventListener('click', function() {openClose('b2')});
	document.getElementById('bb3').addEventListener('click', function() {openClose('b3')});
	document.getElementById('bb4').addEventListener('click', function() {openClose('b4')});
	document.getElementById('bb5').addEventListener('click', function() {openClose('b5')});
	document.getElementById('bb6').addEventListener('click', function() {openClose('b6')});
	document.getElementById('bb7').addEventListener('click', function() {openClose('b7')});
	document.getElementById('bb8').addEventListener('click', function() {openClose('b8')});
	document.getElementById('bb9').addEventListener('click', function() {openClose('b9')});
	document.getElementById('bb10').addEventListener('click', function() {openClose('b10')});
	document.getElementById('bb11').addEventListener('click', function() {openClose('b11')});
	document.getElementById('bb12').addEventListener('click', function() {openClose('b12')});
	document.getElementById('bb13').addEventListener('click', function() {openClose('b13')});
	
	document.getElementById('cc1').addEventListener('click', function() {openClose('c1')});
	document.getElementById('cc2').addEventListener('click', function() {openClose('c2')});
	document.getElementById('cc3').addEventListener('click', function() {openClose('c3')});
	document.getElementById('cc4').addEventListener('click', function() {openClose('c4')});
	document.getElementById('cc5').addEventListener('click', function() {openClose('c5')});
	document.getElementById('cc6').addEventListener('click', function() {openClose('c6')});
	document.getElementById('cc7').addEventListener('click', function() {openClose('c7')});
	document.getElementById('cc8').addEventListener('click', function() {openClose('c8')});
	document.getElementById('cc9').addEventListener('click', function() {openClose('c9')});
	document.getElementById('cc10').addEventListener('click', function() {openClose('c10')});
	document.getElementById('cc11').addEventListener('click', function() {openClose('c11')});
	document.getElementById('cc12').addEventListener('click', function() {openClose('c12')});
	
	document.getElementById('qq1').addEventListener('click', function() {openClose('q1')});
	document.getElementById('qq2').addEventListener('click', function() {openClose('q2')});
	document.getElementById('qq3').addEventListener('click', function() {openClose('q3')});
	document.getElementById('qq4').addEventListener('click', function() {openClose('q4')});
	document.getElementById('qq5').addEventListener('click', function() {openClose('q5')});
	document.getElementById('qq6').addEventListener('click', function() {openClose('q6')});
	document.getElementById('qq7').addEventListener('click', function() {openClose('q7')});
	document.getElementById('qq8').addEventListener('click', function() {openClose('q8')});
	document.getElementById('qq9').addEventListener('click', function() {openClose('q9')});
	document.getElementById('qq10').addEventListener('click', function() {openClose('q10')});
	document.getElementById('qq11').addEventListener('click', function() {openClose('q11')});
	document.getElementById('qq12').addEventListener('click', function() {openClose('q12')});
	document.getElementById('qq13').addEventListener('click', function() {openClose('q13')});
	document.getElementById('qq14').addEventListener('click', function() {openClose('q14')});
	document.getElementById('qq15').addEventListener('click', function() {openClose('q15')});
	document.getElementById('qq16').addEventListener('click', function() {openClose('q16')});
	document.getElementById('qq17').addEventListener('click', function() {openClose('q17')});
	document.getElementById('qq18').addEventListener('click', function() {openClose('q18')});
	document.getElementById('qq19').addEventListener('click', function() {openClose('q19')});
	document.getElementById('qq20').addEventListener('click', function() {openClose('q20')});
	document.getElementById('qq21').addEventListener('click', function() {openClose('q21')});
	document.getElementById('qq22').addEventListener('click', function() {openClose('q22')});
	document.getElementById('qq23').addEventListener('click', function() {openClose('q23')});
	document.getElementById('qq24').addEventListener('click', function() {openClose('q24')});
	document.getElementById('qq25').addEventListener('click', function() {openClose('q25')});
	document.getElementById('qq26').addEventListener('click', function() {openClose('q26')});
	document.getElementById('qq27').addEventListener('click', function() {openClose('q27')});
	document.getElementById('qq28').addEventListener('click', function() {openClose('q28')});
	document.getElementById('qq29').addEventListener('click', function() {openClose('q29')});
	document.getElementById('qq30').addEventListener('click', function() {openClose('q30')});
	
	document.getElementById('aans1').addEventListener('click', function() {openClose('ans1')});
	document.getElementById('aans2').addEventListener('click', function() {openClose('ans2')});
	document.getElementById('aans3').addEventListener('click', function() {openClose('ans3')});
	document.getElementById('aans4').addEventListener('click', function() {openClose('ans4')});
	document.getElementById('aans5').addEventListener('click', function() {openClose('ans5')});
	document.getElementById('aans6').addEventListener('click', function() {openClose('ans6')});
	document.getElementById('aans7').addEventListener('click', function() {openClose('ans7')});
	document.getElementById('aans8').addEventListener('click', function() {openClose('ans8')});
	document.getElementById('aans9').addEventListener('click', function() {openClose('ans9')});
	document.getElementById('aans10').addEventListener('click', function() {openClose('ans10')});
	document.getElementById('aans11').addEventListener('click', function() {openClose('ans11')});
	document.getElementById('aans12').addEventListener('click', function() {openClose('ans12')});
	document.getElementById('aans13').addEventListener('click', function() {openClose('ans13')});
	document.getElementById('aans14').addEventListener('click', function() {openClose('ans14')});
	document.getElementById('aans15').addEventListener('click', function() {openClose('ans15')});
	document.getElementById('aans16').addEventListener('click', function() {openClose('ans16')});
	document.getElementById('aans17').addEventListener('click', function() {openClose('ans17')});
	document.getElementById('aans18').addEventListener('click', function() {openClose('ans18')});
	document.getElementById('aans19').addEventListener('click', function() {openClose('ans19')});
	document.getElementById('aans20').addEventListener('click', function() {openClose('ans20')});
	document.getElementById('aans21').addEventListener('click', function() {openClose('ans21')});
	document.getElementById('aans22').addEventListener('click', function() {openClose('ans22')});
	document.getElementById('aans23').addEventListener('click', function() {openClose('ans23')});
	document.getElementById('aans24').addEventListener('click', function() {openClose('ans24')});
	document.getElementById('aans25').addEventListener('click', function() {openClose('ans25')});
	document.getElementById('aans26').addEventListener('click', function() {openClose('ans26')});
	document.getElementById('aans27').addEventListener('click', function() {openClose('ans27')});
	document.getElementById('aans28').addEventListener('click', function() {openClose('ans28')});
	document.getElementById('aans29').addEventListener('click', function() {openClose('ans29')});
	document.getElementById('aans30').addEventListener('click', function() {openClose('ans30')});
	
	document.getElementById('support').addEventListener('click', addSupport);
};

window.addEventListener('message', receiveMessage, false);

//gets Lock from the Lock directory iframe and puts it in Lock screen
function receiveMessage(evt){
  	if (evt.origin === 'https://passlok.com'){
    	document.getElementById('lockBox').value = evt.data;
		suspendFindLock = true;
		document.getElementById('lockmsg').innerHTML='Give a name to this Lock and save it. Otherwise Clear.'
  	}
}

//end of body script.
</script>

</body></html>